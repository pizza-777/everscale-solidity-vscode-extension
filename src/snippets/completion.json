{
    ".source.ton-solidity": {
        "pragma ton-solidity": {
            "prefix": "pragma ton-solidity",
            "body": "pragma ton-solidity >= ${1:version};",
            "description": [
                "It's used to reject compilation source file with some versions of the compiler.\n",
                "Example:\n",
                "pragma ton-solidity >= 0.57.0; // Check compiler version is at least 0.57.0",
                "pragma ton-solidity ^ 0.57.0; // Check compiler version is at least 0.57.0 and less 0.57.0",
                "pragma ton-solidity < 0.57.0; // Check compiler version is less 0.57.0"
            ]
        },
        "ignoreIntOverflow": {
            "prefix": "ignoreIntOverflow",
            "body": "ignoreIntOverflow;",
            "description": "Turns off binary operation result overflow check."
        },
        "pragma AbiHeader": {
            "prefix": "pragmа AbiHeader",
            "body": "pragma AbiHeader ${1|time,pubkey,expire|};",
            "description": [
                "\n - pubkey (uint256) - optional public key that the message can be signed with.\n - time (uint64) - local time when message was created. Used for replay protection.\n - expire (uint32) - time when the message should be meant as expired.\n\nNote:\n\n - time presents in external messages if pragma AbiHeader time is used OR there is no afterSignatureCheck function defined in the contract.\n - time doesn't present in external messages if pragma AbiHeader time isn't used AND there is afterSignatureCheck function defined in the contract.\nDefined headers are listed in *.abi.json file in header section.\n"
            ]
        },
        "pragma msgValue": {
            "prefix": "pragma msgValue",
            "body": "pragma msgValue ${1:value};",
            "description": [
                "pragma msgValue <value>;\n",
                "Allows specifying default value in nanoevers attached to the internal messages that contract sends to call another contract. If it's not specified, this value is set to 10 000 000 nanoevers.\n",
                "Example:\n",
                "pragma msgValue 123456789;\n",
                "pragma msgValue 1 ton;"
            ]
        },
        "import contract": {
            "prefix": "import",
            "body": "import '${1:contract}';"
        },
        "contract declaration": {
            "prefix": "contract",
            "body": "contract ${1:Name} {\n\t$0\n}"
        },
        "library declaration": {
            "prefix": "library",
            "body": "library ${1:Name} {\n\t$0\n}",
            "description": [
                "Libraries are similar to contracts, but they cannot have state variables and cannot inherit nor be inherited. Libraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (using qualified access like LibName.func(a, b, c)). There is also another way to call library function: obj.func(b, c).\n",
                "For now libraries are stored as a part of the code of the contact that uses libraries. In future, it can be changed."
            ]
        },
        "interface declaration": {
            "prefix": "interface",
            "body": "interface ${1:Name} {\n\t$0\n}"
        },
        "enum declaration": {
            "prefix": "enum",
            "body": "enum ${1:Name} {${2:item1}, ${3:item2}}"
        },
        "struct declaration": {
            "prefix": "struct",
            "body": "struct ${1:Name} {\n    ${2:type name};    \n}"
        },
        "mapping declaration": {
            "prefix": "mapping",
            "body": "mapping (${1:type1}=>${2:type2}) ${3:name};"
        },
        "constructor declaration": {
            "prefix": "constructor",
            "body": "constructor(${1:type} ${2:name}) public {\n\t$0\n}"
        },
        "function declaration": {
            "prefix": "func",
            "body": "function ${1:name}(${2:type} ${3:name}) ${4|public,private,internal,external|} {\n\t$0\n}"
        },
        "function return declaration": {
            "prefix": "funcr",
            "body": "function ${1:name}(${2:type} ${3:name}) ${4|public,private,internal,external|} returns (${5:type}) {\n\t$0\n}"
        },
        "function return in resonsible functions": {
            "prefix": "return{ value: uint128, bounce: bool, flag: uint8 }",
            "body": "return{ value: ${1:uint128}, bounce: ${2:bool}, flag: ${3:uint8} }"
        },
        "function view declaration": {
            "prefix": "funcrview",
            "body": "function ${1:name}(${2:type} ${3:name}) view public returns (${4:type}) {\n\t$0\n}"
        },
        "public": {
            "prefix": "public",
            "body": "public"
        },
        "responsible": {
            "prefix": "responsible",
            "body": "responsible"
        },
        "external": {
            "prefix": "external",
            "body": "external"
        },
        "override": {
            "prefix": "override",
            "body": "override"
        },
        "event declaration": {
            "prefix": "event",
            "body": "event ${1:name}(${2:type} ${3:name});"
        },
        "modifier declaration": {
            "prefix": "modifier",
            "body": "modifier ${1:name}($2) {\n\t$0_;\n}"
        },
        "if else statement": {
            "prefix": "ife",
            "body": "if (${1:condition}) {\n\t$2\n} else {\n\t$0\n}"
        },
        "for statement": {
            "prefix": "for",
            "body": "for (uint256 ${1:index} = 0; $1 < ${2:array}.length; $1${3:++}) {\n\t$0\n}"
        },
        "natspec contract": {
            "prefix": "///nat_contract",
            "body": "/// @title A title that should describe the contract/interface\r\n/// @author The name of the author\r\n/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details",
            "description": "natspec for contract"
        },
        "natspec variable": {
            "prefix": "///nat_statevariable",
            "body": "/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details\r\n/// @return Documents the return variables of a contract’s function state variable\r\n/// @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)",
            "description": "natspec for state variable"
        },
        "natspec function": {
            "prefix": "///nat_function",
            "body": "/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details\r\n/// @param Documents a parameter just like in doxygen (must be followed by parameter name)\r\n/// @return Documents the return variables of a contract’s function state variable\r\n/// @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)",
            "description": "natspec for function"
        },
        "natspec event": {
            "prefix": "///nat_event",
            "body": "/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details\r\n/// @param Documents a parameter just like in doxygen (must be followed by parameter name)",
            "description": "natspec for event"
        },
        "<TvmCell>.depth": {
            "prefix": ".depth",
            "body": "depth()",
            "description": [
                "<TvmCell>.depth() returns(uint64);\n",
                "Returns the depth of TvmCell c. If c has no references, then d = 0; otherwise d is one plus the maximum of depths of cells referred to from c. If c is a Null instead of a Cell, returns zero."
            ]
        },
        "<TvmCell>.dataSize": {
            "prefix": ".dataSize",
            "body": "dataSize(${1:uint n})",
            "description": [
                "<TvmCell>.dataSize(uint n) returns (uint cells, uint bits, uint refs);\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. This function is a wrapper for opcode \"CDATASIZE\" "
            ]
        },
        "<TvmCell>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": "dataSizeQ(${1:uint n})",
            "description": [
                "<TvmCell>.dataSizeQ(uint n) returns (optional(uint cells, uint bits, uint refs));\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. This function is a wrapper for opcode \"CDATASIZEQ\" "
            ]
        },
        "<TvmCell>.toSlice": {
            "prefix": ".toSlice",
            "body": "toSlice()",
            "description": [
                "<TvmCell>.toSlice() returns (TvmSlice);\n",
                "Converts the cell to a slice."
            ]
        },
        "<TvmSlice>.empty": {
            "prefix": ".empty",
            "body": "empty()",
            "description": [
                "<TvmSlice>.empty() returns (bool);\n",
                "Checks whether a Slice is empty (i.e., contains no bits of data and no cell references)."
            ]
        },
        "<TvmSlice>.size": {
            "prefix": ".size",
            "body": "size()",
            "description": [
                "<TvmSlice>.size() returns (uint16 bits, uint8 refs);\n",
                "Returns number of data bits and references in the slice."
            ]
        },
        "<TvmSlice>.dataSize": {
            "prefix": ".dataSize",
            "body": "dataSize(${1:uint n})",
            "description": [
                "<TvmSlice>.dataSize(uint n) returns (uint cells, uint bits, uint refs);\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. Note that the returned count of distinct cells does not take into account the cell that contains the slice itself. This function is a wrapper for opcode SDATASIZE"
            ]
        },
        "<TvmSlice>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": "dataSizeQ(${1:uint n})",
            "description": [
                "<TvmSlice>.dataSizeQ(uint n) returns (optional(uint cells, uint bits, uint refs));\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. Note that the returned count of distinct cells does not take into account the cell that contains the slice itself. This function is a wrapper for opcode SDATASIZEQ"
            ]
        },
        "<TvmSlice>.bits": {
            "prefix": ".bits",
            "body": "bits()",
            "description": [
                "<TvmSlice>.bits() returns (uint16);\n",
                "Returns number of references in the slice."
            ]
        },
        "<TvmSlice>.refs": {
            "prefix": ".refs",
            "body": "refs()",
            "description": [
                "<TvmSlice>.refs() returns (uint8);\n",
                "Returns number of references in the slice."
            ]
        },
        "<TvmSlice>.bitsAndRefs": {
            "prefix": ".bitsAndRefs",
            "body": "bitsAndRefs()",
            "description": [
                "<TvmSlice>.bitsAndRefs() returns (uint16, uint8);\n",
                "Returns number of data bits and references in the slice."
            ]
        },
        "<TvmSlice>.depth": {
            "prefix": ".depth",
            "body": "depth()",
            "description": [
                "<TvmSlice>.depth() returns (uint64);\n",
                "Returns the depth of the slice. If slice has no references, then 0 is returned, otherwise function result is one plus the maximum of depths of the cells referred to from the slice."
            ]
        },
        "<TvmSlice>.hasNBits": {
            "prefix": ".hasNBits",
            "body": "hasNBits(${1:uint16 bits})",
            "description": [
                "<TvmSlice>.hasNBits(uint16 bits) returns (bool);\n",
                "Checks whether the slice contains the specified amount of data bits."
            ]
        },
        "<TvmSlice>.hasNRefs": {
            "prefix": ".hasNRefs",
            "body": "hasNRefs(${1:uint8 bits})",
            "description": [
                "<TvmSlice>.hasNRefs(uint8 bits) returns (bool);\n",
                "Checks whether the slice contains the specified amount of references."
            ]
        },
        "<TvmSlice>.hasNBitsAndRefs": {
            "prefix": ".hasNBitsAndRefs",
            "body": "hasNBitsAndRefs(${1:uint16 bits}, ${2:uint8 refs})",
            "description": [
                "<TvmSlice>.hasNBitsAndRefs(uint16 bits, uint8 refs) returns (bool);\n",
                "Checks whether the slice contains the specified amount of data bits and references."
            ]
        },
        "<TvmSlice>.compare": {
            "prefix": ".compare",
            "body": "compare(${1:TvmSlice other})",
            "description": [
                "<TvmSlice>.compare(TvmSlice other) returns (int8);\n",
                "Lexicographically compares the slice and other data bits of the root slice and returns result as an integer:\n",
                " * 1 - slice > other",
                " * 0 - slice == other",
                " * -1 - slice < other"
            ]
        },
        "<TvmSlice>.loadRef": {
            "prefix": ".loadRef",
            "body": "loadRef()",
            "description": [
                "<TvmSlice>.loadRef() returns (TvmCell);\n",
                "Loads a cell from the slice reference."
            ]
        },
        "<TvmSlice>.loadRefAsSlice": {
            "prefix": ".loadRefAsSlice",
            "body": "loadRefAsSlice()",
            "description": [
                "<TvmSlice>.loadRefAsSlice() returns (TvmSlice);\n",
                "Loads a cell from the slice reference and converts it into a slice."
            ]
        },
        "<TvmSlice>.loadSigned": {
            "prefix": ".loadSigned",
            "body": "loadSigned(${1:uint16 bitSize})",
            "description": [
                "<TvmSlice>.loadSigned(uint16 bitSize) returns (int);\n",
                "Loads a signed integer with the given bitSize from the slice."
            ]
        },
        "<TvmSlice>.loadUnsigned": {
            "prefix": ".loadUnsigned",
            "body": "loadUnsigned(${1:uint16 bitSize})",
            "description": [
                "<TvmSlice>.loadSigned(uint16 bitSize) returns (uint);\n",
                "Loads an unsigned integer with the given bitSize from the slice."
            ]
        },
        "<TvmSlice>.loadTons": {
            "prefix": ".loadTons",
            "body": "loadTons()",
            "description": [
                "<TvmSlice>.loadTons() returns (uint128);\n",
                "Loads (deserializes) VarUInteger 16 and returns an unsigned 128-bit integer."
            ]
        },
        "<TvmSlice>.loadSlice": {
            "prefix": ".loadSlice",
            "body": "loadSlice()",
            "description": [
                "<TvmSlice>.loadSlice(uint length) returns (TvmSlice);\n",
                "<TvmSlice>.loadSlice(uint length, uint refs) returns (TvmSlice);\n",
                "Loads the first length bits and refs references from the slice into a separate slice."
            ]
        },
        "<TvmSlice>.decodeFunctionParams": {
            "prefix": ".decodeFunctionParams",
            "body": "decodeFunctionParams(${1:functionName})",
            "description": [
                "Decodes parameters of the function or constructor (if contract type is provided). This function is usually used in onBounce function.\n",
                "Example:\n",
                "Decode parameters of the public/external function without \"responsible\" attribute:\n",
                "<TvmSlice>.decodeFunctionParams(functionName) returns (TypeA a, TypeB b, ...);\n",
                "Decode parameters of the public function which returns values:\n",
                "<TvmSlice>.decodeFunctionParams(functionName) returns (uint32 callbackFunctionId, TypeA a, TypeB b, ...);\n",
                "Decode constructor parameters:\n",
                "<TvmSlice>.decodeFunctionParams(ContractName) returns (TypeA a, TypeB b, ...);"
            ]
        },
        "<TvmSlice>.skip": {
            "prefix": ".skip",
            "body": "skip(${1:uint length},${2:uint refs})",
            "description": [
                "<TvmSlice>.skip(uint length);\n",
                "<TvmSlice>.skip(uint length, uint refs);\n",
                "Skips the first length bits and refs references from the slice."
            ]
        },
        "<TvmBuilder>.toSlice": {
            "prefix": ".toSlice",
            "body": "toSlice()",
            "description": [
                "<TvmBuilder>.toSlice() returns (TvmSlice);\n",
                "Converts the builder into a slice."
            ]
        },
        "<TvmBuilder>.toCell": {
            "prefix": ".toCell",
            "body": "toCell()",
            "description": [
                "<TvmBuilder>.toCell() returns (TvmCell);\n",
                "Converts the builder into a cell."
            ]
        },
        "<TvmBuilder>.bits": {
            "prefix": ".bits",
            "body": "bits()",
            "description": [
                "<TvmBuilder>.bits() returns (uint16);\n",
                "Returns the number of data bits already stored in the builder."
            ]
        },
        "<TvmBuilder>.refs": {
            "prefix": ".refs",
            "body": "refs()",
            "description": [
                "<TvmBuilder>.refs() returns (uint8);\n",
                "Returns the number of references already stored in the builder."
            ]
        },
        "<TvmBuilder>.bitsAndRefs": {
            "prefix": ".bitsAndRefs",
            "body": "bitsAndRefs()",
            "description": [
                "<TvmBuilder>.bitsAndRefs() returns (uint16 bits, uint8 refs);\n",
                "Returns the number of data bits and references already stored in the builder."
            ]
        },
        "<TvmBuilder>.remBits": {
            "prefix": ".remBits",
            "body": "remBits()",
            "description": [
                "<TvmBuilder>.remBits() returns (uint16);\n",
                "Returns the number of data bits that can still be stored in the builder."
            ]
        },
        "<TvmBuilder>.remRefs": {
            "prefix": ".remRefs",
            "body": "remRefs()",
            "description": [
                "<TvmBuilder>.remRefs() returns (uint8);\n",
                "Returns the number of references that can still be stored in the builder."
            ]
        },
        "<TvmBuilder>.remBitsAndRefs": {
            "prefix": ".remBitsAndRefs",
            "body": "remBitsAndRefs()",
            "description": [
                "<TvmBuilder>.remBitsAndRefs() returns (uint16 bits, uint8 refs);\n",
                "Returns the number of data bits and references that can still be stored in the builder."
            ]
        },
        "<TvmBuilder>.depth": {
            "prefix": ".depth",
            "body": "depth()",
            "description": [
                "<TvmBuilder>.depth() returns (uint64);\n",
                "Returns the depth of the builder. If no cell references are stored in the builder, then 0 is returned; otherwise function result is one plus the maximum of depths of cells referred to from the builder."
            ]
        },
        "<TvmBuilder>.store": {
            "prefix": ".store",
            "body": "store(${1:list_of_values})",
            "description": [
                "<TvmBuilder>.store(list_of_values\\);\n",
                "Stores the list of values in the builder.\n",
                "Example:\n",
                "uint8 a = 11;\n",
                "int16 b = 22;\n",
                "TvmBuilder builder;\n",
                "builder.store(a, b, uint(33));"
            ]
        },
        "<TvmBuilder>.storeOnes": {
            "prefix": ".storeOnes",
            "body": "storeOnes(${1:uint n})",
            "description": [
                "<TvmBuilder>.storeOnes(uint n);\n",
                "Stores n binary ones into Builder."
            ]
        },
        "<TvmBuilder>.storeZeroes": {
            "prefix": ".storeZeroes",
            "body": "storeZeroes(${1:uint n})",
            "description": [
                "<TvmBuilder>.storeZeroes(uint n);\n",
                "Stores n binary zeroes into Builder."
            ]
        },
        "<TvmBuilder>.storeSigned": {
            "prefix": ".storeSigned",
            "body": "storeSigned(${1:int256 value}, ${2:uint16 bitSize})",
            "description": [
                "<TvmBuilder>.storeSigned(int256 value, uint16 bitSize);\n",
                "Stores a signed integer value with given bitSize in the builder."
            ]
        },
        "<TvmBuilder>.storeUnsigned": {
            "prefix": ".storeUnsigned",
            "body": "storeUnsigned(${1:uint256 value}, ${2:uint16 bitSize})",
            "description": [
                "<TvmBuilder>.storeUnsigned(uint256 value, uint16 bitSize);\n",
                "Stores an unsigned integer value with given bitSize in the builder."
            ]
        },
        "<TvmBuilder>.storeRef": {
            "prefix": ".storeRef",
            "body": "storeRef(${1|TvmBuilder b,TvmCell c,TvmSlice s|})",
            "description": [
                "<TvmBuilder>.storeRef(TvmBuilder b);\n",
                "<TvmBuilder>.storeRef(TvmCell c);\n",
                "<TvmBuilder>.storeRef(TvmSlice s);\n",
                "Stores TvmBuilder b/TvmCell c/TvmSlice c in the reference of the builder."
            ]
        },
        "<TvmBuilder>.storeTons": {
            "prefix": ".storeTons",
            "body": "storeTons(${1:uint128 value}})",
            "description": [
                "<TvmBuilder>.storeTons(uint128 value);\n",
                "Stores (serializes) an integer value and stores it in the builder as VarUInteger 16. See TL-B scheme."
            ]
        },
        "<optional(Type)>.get": {
            "prefix": ".get",
            "body": "get()",
            "description": [
                "<optional(Type)>.get() returns (Type);\n",
                "Returns the contained value, if the optional contains one. Otherwise, throws an exception."
            ]
        },
        "<optional(Type)>.hasValue": {
            "prefix": ".hasValue",
            "body": "hasValue()",
            "description": [
                "<optional(Type)>.hasValue() returns (bool);\n",
                "Checks whether opt contains a value."
            ]
        },
        "<vector(Type)>.push": {
            "prefix": ".push",
            "body": "push(${1:Type obj})",
            "description": [
                "<vector(Type)>.push(Type obj);\n",
                "Appends obj to the vector.\n",
                "Example:\n",
                "vector(uint) vect;\n",
                "uint a = 11;\n",
                "vect.push(a);\n",
                "vect.push(111);"
            ]
        },
        "<vector(Type)>.pop": {
            "prefix": ".pop",
            "body": "pop()",
            "description": [
                "<vector(Type)>.pop() returns (Type);\n",
                "Pops the last value from the vector and returns is.\n",
                "Example:\n",
                "vector(uint) vect;\n",
                "...\n",
                "uint a = vect.pop();"
            ]
        },
        "<vector(Type)>.length": {
            "prefix": ".length",
            "body": "length()",
            "description": [
                "<vector(Type)>.length() returns (uint8);\n",
                "Returns length of the vector.\n",
                "Example:\n",
                "vector(uint) vect;\n",
                "...\n",
                "uint8 len = vect.length();"
            ]
        },
        "<vector(Type)>.empty": {
            "prefix": ".empty",
            "body": "empty()",
            "description": [
                "<vector(Type)>.empty() returns (bool);\n",
                "Checks whether the vector is empty.\n",
                "Example:\n",
                "vector(uint) vect;\n",
                "...\n",
                "bool is_empty = vect.empty();"
            ]
        },
        "for range": {
            "prefix": "for_range",
            "body": "for ((uint ${1:key}, uint ${2:value}) : ${3:range_expression}) {\n\t$0\n}",
            "description": [
                "Executes a for loop over a range.\n",
                "Example:\n",
                "for (uint val : arr) {}// iteration over array ",
                "for ((uint32 key, uint value) : map) {} // iteration over mapping ",
                "for ((, uint value) : map) {} // key is omitted  "
            ]
        },
        "repeat": {
            "prefix": "repeat",
            "body": "repeat(${1:uint n}) {\n\t$0\n}",
            "description": "Allows repeating block of code several times. A repeat loop evaluates the expression only one time. This expression must have an unsigned integer type."
        },
        "bitSize": {
            "prefix": "bitSize",
            "body": "bitSize(${1:int x})",
            "description": [
                "bitSize(int x) returns (uint16)",
                "bitSize computes the smallest c ≥ 0 such that x fits into a c-bit signed integer (−2c−1 ≤ x < 2c−1).\n",
                "Example:\n",
                "require(bitSize(12) == 5); // 12 == 1100(in bin sys)",
                "require(bitSize(1) == 2);\n",
                "require(bitSize(-1) == 1);\n",
                "require(bitSize(0) == 0);"
            ]
        },
        "uBitSize": {
            "prefix": "uBitSize",
            "body": "uBitSize(${1:uint x})",
            "description": [
                "uBitSize(int x) returns (uint16)",
                "uBitSize computes the smallest c ≥ 0 such that x fits into a c-bit unsigned integer (0 ≤ x < 2c).\n",
                "Example:\n",
                "require(uBitSize(10) == 4);\n",
                "require(uBitSize(1) == 1);\n",
                "require(uBitSize(0) == 0);"
            ]
        },
        "<struct>.unpack": {
            "prefix": ".unpack",
            "body": "unpack()",
            "description": [
                "<struct>.unpack() returns (TypeA a, TypeB b\\, ...);\n",
                "Unpacks all members stored in the struct.\n",
                "Example:\n",
                "struct MyStruct {\n\tuint a;\n\tint b;\n\taddress c;\n}\n",
                "function f() pure public {\n\tMyStruct s = MyStruct(1, -1, address(2));\n\t(uint a, int b, address c) = s.unpack();\n}"
            ]
        },
        "<array>.empty": {
            "prefix": ".empty",
            "body": "empty()",
            "description": [
                "<array>.empty() returns (bool);\n",
                "Returns status flag whether the array is empty (its length is 0).\n",
                "Example:\n",
                "uint[] arr;\nrequire(arr.empty());\narr.push();\nrequire(!arr.empty());"
            ]
        },
        "<bytes>.empty": {
            "prefix": ".empty",
            "body": "empty()",
            "description": [
                "<bytes>.empty() returns (bool);\n",
                "Returns status flag whether the bytes is empty (its length is 0)."
            ]
        },
        "<bytes>.length": {
            "prefix": ".length",
            "body": "length",
            "description": [
                "<bytes>.length returns (uint)\n",
                "Returns length of the byte array."
            ]
        },
        "<bytes>.toSlice": {
            "prefix": ".toSlice",
            "body": "toSlice()",
            "description": [
                "<bytes>.toSlice() returns (TvmSlice);\n",
                "Converts bytes to TvmSlice.\n",
                "Warning: if length of the array is greater than 127\nthen extra bytes are stored in the first reference of the slice. Use <TvmSlice\\>.loadRef() to load that extra bytes."
            ]
        },
        "<bytes>.dataSize": {
            "prefix": ".dataSize",
            "body": "dataSize(${1:uint n})",
            "description": "<bytes>.dataSize(uint n) returns (uint cells, uint bits, uint refs);"
        },
        "<bytes>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": "dataSizeQ(${1:uint n})",
            "description": "<bytes>.dataSizeQ(uint n) returns (optional(uint cells, uint bits, uint refs));"
        },
        "<bytes>.append": {
            "prefix": ".append",
            "body": "append(${1:bytes tail})",
            "description": [
                "<bytes>.append(bytes tail);\n",
                "Modifies the bytes by concatenating tail bytes to the end of the bytes."
            ]
        },
        "<string>.empty": {
            "prefix": ".empty",
            "body": "empty()",
            "description": [
                "<string>.empty() returns (bool);\n",
                "Returns status flag whether the string is empty (its length is 0)."
            ]
        },
        "<string>.byteLength": {
            "prefix": ".byteLength",
            "body": "byteLength()",
            "description": [
                "<string>.byteLength() returns (uint32);\n",
                "Returns byte length of the string data."
            ]
        },
        "<string>.substr": {
            "prefix": ".substr",
            "body": "substr()",
            "description": [
                "<string>.substr(uint from[, uint count]) returns (string);\n",
                "Returns a substring starting from the\nbyte with number from with byte length count. Note: if count is not set, then the new string will be cut from the from byte to the end of the string.\n",
                "Example:\n",
                "string long = \"0123456789\";\nstring a = long.substr(1, 2); // a = \"12\"\nstring b = long.substr(6); // b = \"6789\""
            ]
        },
        "<string>.append": {
            "prefix": ".append",
            "body": "append(${1:string tail})",
            "description": [
                "<string>.append(string tail);\n",
                "Appends the tail string to the string."
            ]
        },
        "<string>.find": {
            "prefix": ".find",
            "body": "find(${1|substring,byte('symbol')|})",
            "description": [
                "<string>.find(bytes1 symbol) returns (optional(uint32));\n",
                "<string>.find(string substr) returns (optional(uint32));\n",
                "Looks for symbol (or substring) in the string and returns index of the first (find) occurrence. If there is no such symbol in the string, empty optional is returned."
            ]
        },
        "<string>.findLast": {
            "prefix": ".findLast",
            "body": "findLast(${1|substring,byte('symbol')|})",
            "description": [
                "<string>.findLast(bytes1 symbol) returns (optional(uint32));\n",
                "<string>.findLast(string substr) returns (optional(uint32));\n",
                "Looks for symbol (or substring) in the string and returns index of the last (findLast) occurrence. If there is no such symbol in the string, empty optional is returned."
            ]
        },
        "format": {
            "prefix": "format",
            "body": "format(${1:string template}, ${2:TypeA a, TypeB b, ...})",
            "description": [
                "format(string template, TypeA a, TypeB b, ...) returns (string);\n",
                "Builds a string with arbitrary parameters.\n",
                "Example:\n",
                "format(\"Hello {}\", 123) \\\\ \"Hello 123\"\n"
            ]
        },
        "stoi": {
            "prefix": "stoi",
            "body": "stoi(${1:string inputStr})",
            "description": [
                "stoi(string inputStr) returns (optional(int) result);\n",
                "\nConverts a string into an integer. If string starts with '0x' it will be converted from a hexadecimal format, otherwise it is meant to be number in decimal format. Function returns the optional value containing integer, which can be empty in case of illegal characters in the string.\n\nWarning: this function consumes too much gas, that's why it's better not to use it onchain. Example:\n\noptional(int) res;\nres = stoi(\"123\"); // res ==123\nstring hexstr = \"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF123456789ABCDE\";\nres = stoi(hexstr); // res == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF123456789ABCDE\nres = stoi(\"0xag\"); // res == null\n"
            ]
        },
        "address": {
            "prefix": "address",
            "body": "address",
            "description": [
                "Address represents different types of TVM addresses: addr_none, addr_extern, addr_std and addr_var.\n",
                "Constructs an address of type addr_std with\nzero workchain id and given address value.\n",
                "Example:\n",
                "uint address_value;\naddress addrStd = address(address_value);"
            ]
        },
        "address.makeAddrStd": {
            "prefix": "address.makeAddrStd",
            "body": "address.makeAddrStd(${1:workchainId}, ${2:address})",
            "description": "Constructs an address of type addr_std\nwith given workchain id wid and value address_value.\n"
        },
        "address.makeAddrNone": {
            "prefix": "address.makeAddrNone",
            "body": "address.makeAddrNone()",
            "description": "Constructs an address of type addr_none.\n"
        },
        "address.makeAddrExtern": {
            "prefix": "address.makeAddrExtern",
            "body": "address.makeAddrExtern(${1:addrNumber}, ${2:bitCnt})",
            "description": "Constructs an address of type addr_extern with given value with bitCnt bit length.\n"
        },
        "<address>.wid": {
            "prefix": ".wid",
            "body": "wid()",
            "description": [
                "<address>.wid returns (int8);\n",
                "Returns the workchain id of addr_std or addr_var. Throws \"range check error\" exception (error code equal to 5) for another address types."
            ]
        },
        "<address>.value": {
            "prefix": ".value",
            "body": "value()",
            "description": [
                "<address>.value returns (uint);\n",
                "Returns the address value of addr_std or addr_var if addr_var has 256-bit\naddress value. Throws \"range check error\" exception (error code equal to 5) for another address types.\n"
            ]
        },
        "<address>.balance": {
            "prefix": ".balance",
            "body": ".balance",
            "description": [
                "address(this).balance returns (uint128);\n",
                "Returns the balance of this contract in nanoevers.\n"
            ]
        },
        "<address>.currencies": {
            "prefix": ".currencies",
            "body": ".currencies",
            "description": [
                "address(this).currencies returns (ExtraCurrencyCollection);\n",
                "Returns currencies on the balance of this contract.\n"
            ]
        },
        "<address>.getType": {
            "prefix": ".getType",
            "body": "getType()",
            "description": [
                "<address>.getType() returns (uint8);\n",
                "Returns type of the address:\n0 - addr_none 1 - addr_extern 2 - addr_std"
            ]
        },
        "<address>.isStdZero": {
            "prefix": ".isStdZero",
            "body": "isStdZero()",
            "description": [
                "<address>.isStdZero() returns (bool);\n",
                "Returns the result of comparison between this address with zero address of type addr_std.\n"
            ]
        },
        "<address>.isStdAddrWithoutAnyCast": {
            "prefix": ".isStdAddrWithoutAnyCast",
            "body": "isStdAddrWithoutAnyCast()",
            "description": [
                "<address>.isStdAddrWithoutAnyCast() returns (bool);\n",
                "Check whether this address is of type addr_std without any cast.\n"
            ]
        },
        "<address>.isExternZero": {
            "prefix": ".isExternZero",
            "body": "isExternZero()",
            "description": [
                "<address>.isExternZero() returns (bool);\n",
                "Returns the result of comparison between this address with zero address of type addr_extern.\n"
            ]
        },
        "<address>.isNone": {
            "prefix": ".isNone",
            "body": "isNone()",
            "description": [
                "<address>.isNone() returns (bool);\n",
                "Check whether this address is of type addr_none.\n"
            ]
        },
        "<address>.unpack": {
            "prefix": ".unpack",
            "body": "unpack()",
            "description": [
                "<address>.unpack() returns (int8 wid, uint256 value);\n",
                "Parses <address> containing a valid MsgAddressInt (addr_std or addr_var), applies rewriting from the anycast (if present) to the same-length prefix of the address, and returns both the workchain wid and the 256-bit address value. If the address value is not 256-bit, or if <address> is not a valid serialization of MsgAddressInt, throws a cell deserialization exception.\n",
                "It's wrapper for opcode REWRITESTDADDR.\n",
                "Example:\n",
                "(int8 wid, uint addr) = address(this).unpack();\n"
            ]
        },
        "<address>.transfer": {
            "prefix": ".transfer",
            "body": "transfer(${1:uint128 value}, ${2:bool bounce}, ${3:uint16 flag}, ${4:TvmCell body}, ${5:ExtraCurrencyCollection currencies})",
            "description": [
                "<address>.transfer(",
                "      uint128 value, ",
                "      bool bounce, ",
                "      uint16 flag, ",
                "      TvmCell body,",
                "      ExtraCurrencyCollection currencies",
                ");\n",
                "Sends an internal outbound message to defined address. All parameters can be omitted, except value.\n"
            ]
        },
        "<mapping>.min": {
            "prefix": ".min",
            "body": "min()",
            "description": [
                "<map>.min() returns (optional(KeyType, ValueType));\n",
                "Computes the minimal key in the mapping and returns an optional value containing that key and the associated value. If mapping is empty, this function returns an empty optional.\n"
            ]
        },
        "<mapping>.max": {
            "prefix": ".max",
            "body": "max()",
            "description": [
                "<map>.max() returns (optional(KeyType, ValueType));\n",
                "Computes the maximal key in the mapping and returns an optional value containing that key and the associated value. If mapping is empty, this function returns an empty optional.\n"
            ]
        },
        "<mapping>.next": {
            "prefix": ".next",
            "body": "next(${1:KeyType key})",
            "description": [
                "<map>.next(KeyType key) returns (optional(KeyType, ValueType));\n",
                "Computes the maximal key in the mapping that is lexicographically greater than key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n",
                "Example:\n",
                "mapping(uint8 => uint) m;\noptional(uint8, uint) = m.next(-1);"
            ]
        },
        "<mapping>.prev": {
            "prefix": ".prev",
            "body": "prev(${1:KeyType key})",
            "description": [
                "<map>.prev(KeyType key) returns (optional(KeyType, ValueType));\n",
                "Computes the minimal key in the mapping that is lexicographically less than key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n",
                "Example:\n",
                "mapping(uint8 => uint) m;\noptional(uint8, uint) = m.prev(123);"
            ]
        },
        "<mapping>.nextOrEq": {
            "prefix": ".nextOrEq",
            "body": "nextOrEq(${1:KeyType key})",
            "description": [
                "<map>.nextOrEq(KeyType key) returns (optional(KeyType, ValueType));\n",
                "Computes the maximal key in the mapping that is lexicographically greater than or equal to key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n"
            ]
        },
        "<mapping>.prevOrEq": {
            "prefix": ".prevOrEq",
            "body": "prevOrEq(${1:KeyType key})",
            "description": [
                "<map>.prevOrEq(KeyType key) returns (optional(KeyType, ValueType));\n",
                "Computes the minimal key in the mapping that is lexicographically less than or equal to key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n"
            ]
        },
        "<mapping>.delMin": {
            "prefix": ".delMin",
            "body": "delMin()",
            "description": [
                "<map>.delMin() returns (optional(KeyType, ValueType));\n",
                "If mapping is not empty then this function computes the minimal key of the mapping, deletes that key and the associated value from the mapping and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key.\n"
            ]
        },
        "<mapping>.delMax": {
            "prefix": ".delMax",
            "body": "delMax()",
            "description": [
                "<map>.delMax() returns (optional(KeyType, ValueType));\n",
                "If mapping is not empty then this function computes the maximum key of the mapping, deletes that key and the associated value from the mapping and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key.\n"
            ]
        },
        "<mapping>.fetch": {
            "prefix": ".fetch",
            "body": "fetch(${1:KeyType key})",
            "description": [
                "<map>.fetch(KeyType key) returns (optional(ValueType));\n",
                "Checks whether key presents in the mapping and returns an optional with the associated value. Returns an empty optional if there is no such key.\n"
            ]
        },
        "<mapping>.exists": {
            "prefix": ".exists",
            "body": "exists(${1:KeyType key})",
            "description": [
                "<map>.exists(KeyType key) returns (bool);\n",
                "Returns a status flag whether key presents in the mapping.\n"
            ]
        },
        "<mapping>.empty": {
            "prefix": ".empty",
            "body": "empty()",
            "description": [
                "<map>.empty() returns (bool);\n",
                "Returns a status flag whether the mapping is empty.\n"
            ]
        },
        "<mapping>.replace": {
            "prefix": ".replace",
            "body": "replace(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "<map>.replace(KeyType key, ValueType value) returns (bool);\n",
                "Sets the value associated with key only if key presents in the mapping and returns the success flag.\n"
            ]
        },
        "<mapping>.add": {
            "prefix": ".add",
            "body": "add(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "<map>.add(KeyType key, ValueType value) returns (bool);\n",
                "Sets the value associated with key only if key does not present in the mapping.\n"
            ]
        },
        "<mapping>.getSet": {
            "prefix": ".getSet",
            "body": "getSet(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "<map>.getSet(KeyType key, ValueType value) returns (optional(ValueType));\n",
                "Sets the value associated with key, but also returns an optional with the old value associated with the key, if presents. Otherwise, returns an empty optional.\n"
            ]
        },
        "<mapping>.getAdd": {
            "prefix": ".getAdd",
            "body": "getAdd(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "<map>.getAdd(KeyType key, ValueType value) returns (optional(ValueType));\n",
                "Sets the value associated with key, but only if key does not present in the mapping. Returns an optional with the old value without changing the dictionary if that value presents in the mapping, otherwise returns an empty optional.\n"
            ]
        },
        "<mapping>.getReplace": {
            "prefix": ".getReplace",
            "body": "getReplace(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "<map>.getReplace(KeyType key, ValueType value) returns (optional(ValueType));\n",
                "Sets the value associated with key, but only if key presents in the mapping. On success, returns an optional with the old value associated with the key. Otherwise, returns an empty optional.\n"
            ]
        },
        "require": {
            "prefix": "require",
            "body": "require(${1:bool condition}, ${2:uint errorCode}, ${3:Type exceptionArgument});",
            "description": [
                "require(bool condition, [uint errorCode = 100, [Type exceptionArgument]]);\n",
                "require function can be used to check the condition and throw an exception if the condition is not met. The function takes condition and optional parameters: error code (unsigned integer) and the object of any type.\n",
                "Example:\n",
                "uint a = 5;\n",
                "require(a == 6, 101, \"a is not equal to six\");"
            ]
        },
        "revert": {
            "prefix": "revert",
            "body": "revert(${1:uint errorCode}, ${2:Type exceptionArgument})",
            "description": [
                "revert(uint errorCode = 100, [Type exceptionArgument]);\n",
                "revert function can be used to throw exceptions. The function takes an optional error code (unsigned integer) and the object of any type.\n",
                "Example:\n",
                "revert(102, \"We have a some problem\");"
            ]
        },
        "receive": {
            "prefix": "receive",
            "body": "receive () external {\n\t$0\n}",
            "description": [
                "receive function is called in 2 cases:",
                "1. msg.data (or message body) is empty.",
                "2. msg.data starts with 32-bit zero.",
                "\nThen message body may contain data, for example string with comment."
            ]
        },
        "fallback": {
            "prefix": "fallback",
            "body": "fallback () external {\n\t$0\n}",
            "description": [
                "fallback function is called when a body of an inbound internal/external message in such cases:",
                "1. The message contains a function id that the contract doesn't contain.",
                "2. Bit length of message between 1 and 31 (including).",
                "3. Bit length of message equals to zero, but the message contains reference(s)."
            ]
        },
        "onBounce": {
            "prefix": "onBounce",
            "body": "onBounce (TvmSlice body) external {\n\t$0\n}",
            "description": [
                "onBounce function is executed when contract receives a bounced inbound internal message. The message is generated by the network if the contract sends an internal message with bounce: true and",
                " * called contract doesn't exist;",
                " * called contract fails at storage/credit/computing phase (not at action phase!).",
                "\nThe message is generated only if the remaining message value is enough for sending one back.\n",
                "body is empty or contains at most 256 data bits of the original message (without references). The function id takes 32 bits and parameters can take at most 224 bits. It depends on the network config. If onBounce function is not defined then the contract does nothing on receiving a bounced inbound internal message.\n",
                "If the onBounce function throws an exception then another bounced messages are not generated."
            ]
        },
        "onTickTock": {
            "prefix": "onTickTock",
            "body": "onTickTock (TvmSlice isTock) external {\n\t$0\n}",
            "description": "onTickTock function is executed on tick/tock transaction. That transactions are automatically invoked for certain special accounts. For tick transactions isTock is false, for tock transactions - true.\n"
        },
        "onCodeUpgrade": {
            "prefix": "onCodeUpgrade",
            "body": "onCodeUpgrade () private {\n\t$0\n}",
            "description": "onCodeUpgrade function can have arbitrary set of arguments and should be executed after tvm.setcode() function call. In this function tvm.resetStorage() should be called if the set of state variables is changed in the new version of the contract. This function implicitly calls tvm.commit(). Then return from onCodeUpgrade TVM execution is finished with exit code 0.\n"
        },
        "afterSignatureCheck": {
            "prefix": "afterSignatureCheck",
            "body": "afterSignatureCheck (TvmSlice body, TvmCell message) private inline returns (TvmSlice){\n\t$0\n}",
            "description": "afterSignatureCheck function is used to define custom replay protection function instead of the default one. Never call tvm.commit() or tvm.accept() in the function because the function can be called before calling constructor.\n"
        },
        "msg.sender": {
            "prefix": "msg.sender",
            "body": "msg.sender",
            "description": [
                "msg.sender returns (address);\n",
                "Returns:\n\t* sender of the message for internal message.\n\t* address(0) for external message.\n\t* address(0) for tick/tock transaction."
            ]
        },
        "msg.value": {
            "prefix": "msg.value",
            "body": "msg.value",
            "description": [
                "msg.value returns (uint128);\n",
                "Returns:\n\tBalance of the inbound message in nanoevers for internal message.\n\t0 for external message.\n\tUndefined value for tick/tock transaction."
            ]
        },
        "msg.currencies": {
            "prefix": "msg.currencies",
            "body": "msg.currencies",
            "description": [
                "msg.currencies returns (ExtraCurrencyCollection);\n",
                "Collections of arbitrary currencies contained in the balance of the inbound message."
            ]
        },
        "msg.pubkey": {
            "prefix": "msg.pubkey",
            "body": "msg.pubkey()",
            "description": [
                "msg.pubkey() returns (uint256);\n",
                "Returns sender's public key, obtained from the body of the external inbound message. If the message is not signed, msg.pubkey() returns 0. If the message is signed and message header (pragma AbiHeader) does not contain pubkey then msg.pubkey() is equal to tvm.pubkey()."
            ]
        },
        "msg.isInternal": {
            "prefix": "msg.isInternal",
            "body": "msg.isInternal",
            "description": "Returns whether the contract is called by internal message."
        },
        "msg.isExternal": {
            "prefix": "msg.isExternal",
            "body": "msg.isExternal",
            "description": "Returns whether the contract is called by external message."
        },
        "msg.isTickTock": {
            "prefix": "msg.isTickTock",
            "body": "msg.isTickTock",
            "description": "Returns whether the contract is called by tick/tock transactions."
        },
        "msg.createdAt": {
            "prefix": "msg.createdAt",
            "body": "msg.createdAt",
            "description": [
                "msg.createdAt returns (uint32);\n",
                "Returns a field created_at of the external inbound message.\n"
            ]
        },
        "msg.data": {
            "prefix": "msg.data",
            "body": "msg.data",
            "description": [
                "msg.data returns (TvmSlice);\n",
                "Returns a payload of the inbound message.\n"
            ]
        },
        "tvm.accept": {
            "prefix": "tvm.accept",
            "body": "tvm.accept();",
            "description": [
                "tvm.accept();\n",
                "Executes TVM instruction \"ACCEPT\" (TVM - A.11.2. - F800). This instruction sets current gas limit to its maximal allowed value. This action is required to process external messages, which bring no value.\n"
            ]
        },
        "tvm.commit": {
            "prefix": "tvm.commit",
            "body": "tvm.commit();",
            "description": [
                "tvm.commit();\n",
                "Creates a \"check point\" of the state variables (by copying them from c7 to c4) and register c5. If the contract throws an exception at the computing phase then the state variables and register c5 will roll back to the \"check point\", and the computing phase will be considered \"successful\". If contract doesn't throw an exception, it has no effect.\n"
            ]
        },
        "tvm.rawCommit": {
            "prefix": "tvm.rawCommit",
            "body": "tvm.rawCommit();",
            "description": [
                "tvm.rawCommit();\n",
                "Creates a \"check point\" of the state variables but  doesn't copy the state variables from c7 to c4. It's a wrapper for opcode COMMIT. See TVM.\n",
                "Note: Don't use tvm.rawCommit() after tvm.accept() in processing external messages because you don't save from c7 to c4 the hidden state variable timestamp, which is used for replay protection.\n"
            ]
        },
        "tvm.getData": {
            "prefix": "tvm.getData",
            "body": "tvm.getData();",
            "description": [
                "tvm.getData() returns (TvmCell);\n",
                "It's an experimental function.\n A dual of the tvm.setData() returning value of c4 register. Getting a raw storage cell is useful when upgrading a new version of contract that introduces an altered data layout.\nManipulation with a raw storage cell requires an understanding of the way the compiler layouts the data. Refer to the description of tvm.setData() below to get more details.\n",
                "Note: state variables and replay protection timestamp stored in data cell have the same values that were before the transaction. See tvm.commit() how to update register c4.\n"
            ]
        },
        "tvm.setData": {
            "prefix": "tvm.setData",
            "body": "tvm.setData(${1:TvmCell});",
            "description": [
                "tvm.setData() returns (TvmCell);\n",
                "It's an experimental function.Set cell data to register c4. \n",
                "Note, after returning from a public function all state variable from c7 will copy to c4 and tvm.setData will have no effect. Example of usage of such hint to set c4:\n",
                "TvmCell data = ...;\n",
                "tvm.setData(data); // set register c4\n",
                "tvm.rawCommit();   // save register c4 and c5\n",
                "revert(200);       // throw the exception to terminate the transaction\n",
                "Be careful with the hidden state variable timestamp and think about possibility of replaying external messages.\n"
            ]
        },
        "tvm.log": {
            "prefix": "tvm.log",
            "body": "tvm.log(${1:string log});",
            "description": [
                "tvm.log(string log);\n",
                "Dumps log string. This function is wrapper for TVM instructions PRINTSTR (for constant literal strings shorter than 16 symbols) and STRDUMP (for other strings). logtvm is an alias for tvm.log(string).\nNote: For long strings dumps only the first 127 symbols.\n",
                "Example:\n",
                "tvm.log(\"Hello,world!\");\n"
            ]
        },
        "tvm.hexdump": {
            "prefix": "tvm.hexdump",
            "body": "tvm.hexdump(${1:T a});",
            "description": [
                "tvm.hexdump(T a);\n",
                "Dumps cell data or integer. Note that for cells this function dumps data only from the first cell. T must be an integer type or TvmCell.\n",
                "Example:\n",
                "tvm.hexdump(123);\\\\Output: 7B\n"
            ]
        },
        "tvm.bindump": {
            "prefix": "tvm.bindump",
            "body": "tvm.bindump(${1:T a});",
            "description": [
                "tvm.bindump(T a);\n",
                "Dumps cell data or integer. Note that for cells this function dumps data only from the first cell. T must be an integer type or TvmCell.\n",
                "Example:\n",
                "tvm.bindump(123);\\\\Output: 1111011\n"
            ]
        },
        "tvm.setcode": {
            "prefix": "tvm.setcode",
            "body": "tvm.setcode(${1:TvmCell newCode});",
            "description": [
                "tvm.setcode(TvmCell newCode);\n",
                "This command creates an output action that would change this smart contract code to that given by Cell newCode (this change will take effect only after the successful termination of the current run of the smart contract).\n"
            ]
        },
        "tvm.rawConfigParam": {
            "prefix": "tvm.rawConfigParam",
            "body": "tvm.rawConfigParam(${1:uint8 paramNumber});",
            "description": [
                "tvm.rawConfigParam(uint8 paramNumber) returns (TvmCell cell, bool status);\n",
                "Executes TVM instruction \"CONFIGPARAM\" (TVM - A.11.4. - F832). Returns the value of the global configuration parameter with integer index paramNumber as a cell and a boolean status.\n"
            ]
        },
        "tvm.configParam": {
            "prefix": "tvm.configParam",
            "body": "tvm.configParam(${1:uint8 paramNumber});",
            "description": [
                "tvm.configParam(uint8 paramNumber) returns (TypeA a, TypeB b, ...);\n",
                "Executes TVM instruction \"CONFIGPARAM\" (TVM - A.11.4. - F832). This command returns the value of the global configuration parameter with integer index paramNumber. Argument should be an integer literal. Supported paramNumbers: 1, 15, 17, 34.\n"
            ]
        },
        "tvm.rawReserve": {
            "prefix": "tvm.rawReserve",
            "body": "tvm.rawReserve(${1:uint value}, ${2:uint8 flag});",
            "description": [
                "tvm.rawReserve(uint value, uint8 flag);\ntvm.rawReserve(uint value, ExtraCurrencyCollection currency, uint8 flag);\n",
                "Creates an output action which reserves reserve nanoevers. It is roughly equivalent to create an outbound message carrying reserve nanoevers to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. It's a wrapper for opcodes \"RAWRESERVE\" and \"RAWRESERVEX\".\n"
            ]
        },
        "tvm.hash": {
            "prefix": "tvm.hash",
            "body": "tvm.hash(${1|TvmCell cellTree,string data,bytes data,TvmSlice data|});",
            "description": [
                "tvm.hash(TvmCell cellTree) returns (uint256);\ntvm.hash(string data) returns (uint256);\ntvm.hash(bytes data) returns (uint256);\ntvm.hash(TvmSlice data) returns (uint256);\n",
                "Executes TVM instruction \"HASHCU\" or \"HASHSU\". It computes the representation hash of a given argument and returns it as a 256-bit unsigned integer. For string and bytes it computes hash of the tree of cells, which contains data, but not data itself. See sha256 to count hash of data.\n"
            ]
        },
        "tvm.checkSign": {
            "prefix": "tvm.checkSign",
            "body": "tvm.checkSign(${1|uint256 hash\\, uint256 SignHighPart\\, uint256 SignLowPart\\, uint256 pubkey,uint256 hash\\, TvmSlice signature\\, uint256 pubkey,TvmSlice data\\, TvmSlice signature\\, uint256 pubkey|});",
            "description": "returns (bool)\nExecutes TVM instruction \"CHKSIGNU\" for variants 1 and 2. This command checks the Ed25519-signature of a hash using public key pubkey. Signature is represented by two uint256 SignHighPart and SignLowPart in the first variant and by a slice signature in the second variant. In the third variant executes TVM instruction \"CHKSIGNS\". This command checks Ed25519-signature of data using public key pubkey. Signature is represented by a slice signature.\n"
        },
        "tvm.insertPubkey": {
            "prefix": "tvm.insertPubkey",
            "body": "tvm.insertPubkey(${1:TvmCell stateInit}, ${2:uint256 pubkey})",
            "description": [
                "tvm.insertPubkey(TvmCell stateInit, uint256 pubkey) returns (TvmCell);\n",
                "Inserts a public key into stateInit data field. If stateInit has wrong format then throws exception.\n"
            ]
        },
        "tvm.buildStateInit": {
            "prefix": "tvm.buildStateInit",
            "body": "tvm.buildStateInit(${1|TvmCell code\\, TvmCell data, TvmCell code\\, TvmCell data\\, uint8 splitDepth\\, {code: TvmCell code\\, data: TvmCell data\\, splitDepth: uint8 splitDepth\\, pubkey: uint256 pubkey\\, contr: contract Contract\\, varInit: {VarName0: varValue0\\, ...}}|})",
            "description": [
                "returns (TvmCell stateInit)\n",
                "Generates a StateInit (TBLKCH - 3.1.7.) from code and data.\n"
            ]
        },
        "tvm.buildDataInit": {
            "prefix": "tvm.buildDataInit",           
            "body": "tvm.buildDataInit({pubkey: uint256 pubkey, contr: contract Contract, varInit: {VarName0: varValue0, ...}})",
            "description": [
                "Generates data field of the StateInit (TBLKCH - 3.1.7.). Parameters are the same as in tvm.buildStateInit().\n"               
            ]
        },
        "tvm.stateInitHash": {
            "prefix": "tvm.stateInitHash",
            "body": "stateInitHash(${1:uint256 codeHash}, ${2:uint256 dataHash}, ${3:uint16 codeDepth}, ${4:uint16 dataDepth})",
            "description": [
                "Calculates hash of the stateInit for given code and data specifications.\n",
                "Example:\n",
                "TvmCell code = ...;\nTvmCell data = ...;\nuint codeHash = tvm.hash(code);\nuint dataHash = tvm.hash(data);\nuint16 codeDepth = code.depth();\nuint16 dataDepth = data.depth();\nuint256 hash = tvm.stateInitHash(codeHash, dataHash, codeDepth, dataDepth);\n"
            ]
        },
        "tvm.deploy": {
            "prefix": "tvm.deploy",
            "body": "tvm.deploy(${1:TvmCell stateInit}, ${2:TvmCell payload}, ${3:uint128 value}, ${4:int8 wid})",
            "description": [
                "returns(address);\n",
                "Deploys a new contract and returns the address of the deployed contract. This function may be useful if you want to write a universal contract that can deploy any contract.\n"
            ]
        },
        "tvm.code": {
            "prefix": "tvm.code",
            "body": "tvm.code()",
            "description": [
                "tvm.code() returns (TvmCell);\n",
                "Returns contract's code.\n"
            ]
        },
        "tvm.codeSalt": {
            "prefix": "tvm.codeSalt",
            "body": "tvm.codeSalt(${1:TvmCell code})",
            "description": [
                "tvm.codeSalt(TvmCell code) returns (optional(TvmCell) optSalt);\n",
                "If code contains salt then optSalt contains one. Otherwise, optSalt doesn't contain any value.\n"
            ]
        },
        "tvm.setCodeSalt": {
            "prefix": "tvm.setCodeSalt",
            "body": "setCodeSalt(${1:TvmCell code}, ${2:TvmCell salt})",
            "description": [
                "Inserts salt into code and returns new code newCode.\n",
                "tvm.setCodeSalt(TvmCell code, TvmCell salt) returns (TvmCell newCode);\n"
            ]
        },
        "tvm.pubkey": {
            "prefix": "tvm.pubkey",
            "body": "tvm.pubkey()",
            "description": [
                "tvm.pubkey() returns (uint256);\n",
                "Returns contract's public key, stored in contract data. If key is not set, function returns 0.\n"
            ]
        },
        "tvm.setPubkey": {
            "prefix": "tvm.setPubkey",
            "body": "tvm.setPubkey(${1:uint256 newPubkey})",
            "description": [
                "tvm.setPubkey(uint256 newPubkey);\n",
                "Set new contract's public key.\n"
            ]
        },
        "tvm.setCurrentCode": {
            "prefix": "tvm.setCurrentCode",
            "body": "tvm.setCurrentCode(${1:TvmCell newCode})",
            "description": [
                "tvm.setCurrentCode(TvmCell newCode);\n",
                "Changes this smart contract current code to that given by Cell newCode. Unlike tvm.setcode() this function changes code of the smart contract only for current TVM execution, but has no effect after termination of the current run of the smart contract.\n"
            ]
        },
        "tvm.resetStorage": {
            "prefix": "tvm.resetStorage",
            "body": "tvm.resetStorage()",
            "description": "Resets all state variables to their default values.\n"
        },
        "tvm.functionId": {
            "prefix": "tvm.functionId",
            "body": "tvm.functionId(${1:functionName})",
            "description": [
                "// id of public function\ntvm.functionId(functionName) returns (uint32);\n// id of public constructor\ntvm.functionId(ContractName) returns (uint32);\n",
                "Returns a function id (uint32) for public/external function or constructor.\n"
            ]
        },
        "tvm.encodeBody": {
            "prefix": "tvm.encodeBody",
            "body": "tvm.encodeBody(${1:function},${2:callbackFunction},${3: arg0, arg1, arg2, ...})",
            "description": [
                "tvm.encodeBody(function, arg0, arg1, arg2, ...) returns (TvmCell);\ntvm.encodeBody(function, callbackFunction, arg0, arg1, arg2, ...) returns (TvmCell);\n",
                "Constructs a function call message body that can be used as the payload for <address>.transfer(). If function is responsible then callbackFunction parameter must be set.\n"
            ]
        },
        "tvm.exit": {
            "prefix": "tvm.exit",
            "body": "tvm.exit()",
            "description": [
                "tvm.exit();\n",
                "Function are used to save state variables and to quickly terminate execution of the smart contract.\nExit code is equal to zero\n"
            ]
        },
        "tvm.exit1": {
            "prefix": "tvm.exit1",
            "body": "tvm.exit1()",
            "description": [
                "tvm.exit1();\n",
                "Function are used to save state variables and to quickly terminate execution of the smart contract.Exit code is equal to one\n"
            ]
        },
        "tvm.buildExtMsg": {
            "prefix": "tvm.buildExtMsg",
            "body": "tvm.buildExtMsg({\n\tdest: ${1:address},\n\ttime:${2:uint64},\n\texpire:${3:uint64},\n\tcall:{${4:functionIdentifier[, list_of_function_arguments]}},\n\tsign:${5:bool},\n\tpubkey:${6:optional(uint256)},\n\tcallbackId:${8:uint32},\n\tonErrorId:${9:uint32},\n\tstateInit:${10:TvmCell},\n\tsignBoxHandle:${11:optional(uint32)}\n\t\\});",
            "description": [
                "tvm.buildExtMsg({\n    dest: address,\n    time: uint64,\n    expire: uint32,\n    call: {function, [callbackFunction,] arg0, arg1, arg2, ...},\n    sign: bool,\n    pubkey: optional(uint256),\n    callbackId: uint32,\n    onErrorId: uint32,\n    stateInit: TvmCell,\n    signBoxHandle: optional(uint32)\n})\nreturns (TvmCell);\n",
                "Function should be used only offchain and intended to be used only in debot contracts. Allows creating an external inbound message, that calls the func function of the contract on address destination with specified function arguments.\n\nMandatory parameters that are used to form a src address field that is used for debots: \n - abiVer :  ABI version. \n - callbackId : identifier of the callback function.\n - onErrorId : identifier of the function that is called in case of error.\n - signBoxHandle : handle of the sign box entity, that engine will use to sign the message.\n\nThese parameters are stored in addr_extern and placed to the src field of the message. Message is of type ext_in_msg_info and src addr is of type addr_extern but stores special data:\n - callback id : 32 bits; \n - on error id : 32 bits;\n - abi version : 8 bits;\n - header mask : 3 bits in such order: time, expire, pubkey;\n - optional value signBoxHandle : 1 bit (whether value presents) + [32 bits].\n\nOther function parameters define fields of the message: \n - time : message creation timestamp. Used for replay attack protection, encoded as 64 bit Unix time in milliseconds.\n - expire : Unix time (in seconds, 32 bit) after that message should not be processed by contract.\n - pubkey : public key from key pair used for signing the message body. This parameter is optional and can be omitted.\n - sign : constant bool flag that shows whether message should contain signature. If set to true, message is generated with signature field filled with zeroes. This parameter is optional and can be omitted (in this case is equal to false).\nUser can also attach stateInit to the message using stateInit parameter.\n\nFunction throws an exception with code 64 if function is called with wrong parameters (pubkey is set and has value, but sign is false or omitted).\n"
            ]
        },
        "tvm.buildIntMsg": {
            "prefix": "tvm.buildIntMsg",
            "body": "tvm.buildIntMsg({\n\tdest:${1:address},\n\tvalue:${2:uint128},\n\tcall:{${4:function, [callbackFunction, ] arg0, arg1, arg2, ...}},\n\tbounce:${5:bool},\n\tcurrencies:${6:ExtraCurrencyCollection}\n\t\\});",
            "description": [
                "tvm.buildIntMsg({\n    dest: address,\n    value: uint128,\n    call: {function, [callbackFunction,] arg0, arg1, arg2, ...},\n    bounce: bool,\n    currencies: ExtraCurrencyCollection\n    stateInit: TvmCell\n})\nreturns (TvmCell);\n",
                "Generates an internal outbound message that contains function call. The cell can be used to send a message using tvm.sendrawmsg(). If the function is responsible then callbackFunction parameter must be set.\n\ndest, value and call parameters are mandatory. Another parameters can be omitted. See <address>.transfer() where these options and their default values are described.\n "
            ]
        },
        "tvm.sendrawmsg": {
            "prefix": "tvm.sendrawmsg",
            "body": "tvm.sendrawmsg(${1:TvmCell msg}, ${2:uint8 flag});",
            "description": [
                "tvm.sendrawmsg(TvmCell msg, uint8 flag);\n",
                "Send the internal/external message msg with flag. It's wrapper for opcode SENDRAWMSG (TVM - A.11.10). Internal message msg can be generated by tvm.buildIntMsg().\n"
            ]
        },
        "tvm.setGasLimit": {
            "prefix": "tvm.setGasLimit",
            "body": "tvm.setGasLimit(${1:uint g});",
            "description": [
                "tvm.setGasLimit(uint g);\n",
                "\nExecutes TVM instruction \"SETGASLIMIT\" (TVM - A.11.2).\nSets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that tvm.setGasLimit(...) with an argument g ≥ 263 − 1 is equivalent to tvm.accept().\ntvm.setGasLimit() is similar to tvm.accept(). tvm.accept() sets gas limit gl to the maximum possible value (depends on the network configuration parameters, usually is equal to 1_000_000 units of gas). tvm.setGasLimit() is generally used for accepting external messages and restricting max possible gas consumption. It may be used to protect from flood by \"bad\" owner in a contract that is used by multiple users. \nLet's consider some scenario:\n\n - Check whether msg.pubkey() != 0 and msg.pubkey() belongs to the list of trusted public keys;\n - Check whether m_floodCounter[msg.pubkey()] < 5 where m_floodCounter is count of pending operations of msg.pubkey() user.\n - tvm.setGasLimit(75_000); accept external message and set gas limit to 75_000.\n - ++m_floodCounter[msg.pubkey()]; increase count of pending operations for current users.\n - tvm.commit(); save current state if it needs\n - Do other things.\n\nSo if some user's public key will be stolen, then a hacker can spam with external messages and burn at most 5 * 75_000 units of gas instead of 5 * 1_000_000, because we use tvm.setGasLimit() instead of tvm.accept().\n"
            ]
        },
        "math.min": {
            "prefix": "math.min",
            "body": "math.min(${1:T a, T b, ...});",
            "description": [
                "math.min(T a, T b, ...) returns (T);\n",
                "Returns the minimal value of the passed arguments. T should be an integer or fixed point type\n"
            ]
        },
        "math.max": {
            "prefix": "math.max",
            "body": "math.max(${1:T a, T b, ...});",
            "description": [
                "math.max(T a, T b, ...) returns (T);\n",
                "Returns the maximal value of the passed arguments. T should be an integer or fixed point type\n"
            ]
        },
        "math.minmax": {
            "prefix": "math.minmax",
            "body": "math.minmax(${1:T a, T b, ...});",
            "description": [
                "math.minmax(T a, T b) returns (T min, T max);\n",
                "Returns minimal and maximal values of the passed arguments. T should be an integer or fixed point type\n",
                "Example:\n",
                "(uint a, uint b) = math.minmax(20, 10); // (10, 20)"
            ]
        },
        "math.abs": {
            "prefix": "math.abs",
            "body": "math.abs(${1|intM val,fixedMxN val|});",
            "description": [
                "math.abs(intM val) returns (intM);\nmath.abs(fixedMxN val) returns (fixedMxN);\n",
                "Computes the absolute value of the given integer.\n"
            ]
        },
        "math.modpow2": {
            "prefix": "math.modpow2",
            "body": "math.modpow2(${1:uint value}, ${2:uint power});",
            "description": [
                "math.modpow2(uint value, uint power) returns (uint);\n",
                "Computes the value modulo 2^power. Note that power should be a constant integer.\n"
            ]
        },
        "math.divc": {
            "prefix": "math.divc",
            "body": "math.divc(${1:T a}, ${2:T b});",
            "description": [
                "math.divc(T a, T b) returns (T);\n",
                "Returns result of the division of two integers. T should be an integer or fixed point type. The return value is rounded ceiling\n"
            ]
        },
        "math.divr": {
            "prefix": "math.divr",
            "body": "math.divr(${1:T a}, ${2:T b});",
            "description": [
                "math.divr(T a, T b) returns (T);\n",
                "Returns result of the division of two integers. T should be an integer or fixed point type. The return value is rounded nearest\n"
            ]
        },
        "math.muldiv": {
            "prefix": "math.muldiv",
            "body": "math.muldiv(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "math.muldiv(T a, T b, T c) returns (T);\n",
                "Multiplies two values and then divides the result by a third value. T is integer type. The return value is rounded(floor).\n"
            ]
        },
        "math.muldivr": {
            "prefix": "math.muldivr",
            "body": "math.muldivr(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "math.muldivr(T a, T b, T c) returns (T);\n",
                "Multiplies two values and then divides the result by a third value. T is integer type. The return value is rounded(nearest).\n"
            ]
        },
        "math.muldivc": {
            "prefix": "math.muldivc",
            "body": "math.muldivc(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "math.muldivc(T a, T b, T c) returns (T);\n",
                "Multiplies two values and then divides the result by a third value. T is integer type. The return value is rounded(ceiling).\n"
            ]
        },
        "math.muldivmod": {
            "prefix": "math.muldivmod",
            "body": "math.muldivmod(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "math.muldivmod(T a, T b, T c) (T result, T remainder);\n",
                "This instruction multiplies first two arguments, divides the result by third argument and returns the result and the remainder. Intermediate result is stored in the 514 bit buffer, and the final result is rounded to the floor.\n"
            ]
        },
        "math.divmod": {
            "prefix": "math.divmod",
            "body": "math.divmod(${1:T a}, ${2:T b});",
            "description": [
                "math.divmod(T a, T b) returns (T result, T remainder);\n",
                "This instruction divides the first number by the second one and returns the result\nand the remainder. Result is rounded to the floor. T is integer type.\n"
            ]
        },
        "math.sign": {
            "prefix": "math.sign",
            "body": "math.sign(${1:int val});",
            "description": [
                "math.sign(int val) returns (int8);\n",
                "Returns number in case of sign of the argument value val:\n\t-1 if val is negative;\n\t0 if val is zero;\n\t1 if val is positive.\n"
            ]
        },
        "tx.timestamp": {
            "prefix": "tx.timestamp",
            "body": "tx.timestamp",
            "description": [
                "tx.timestamp returns (uint64);\n",
                "Returns the logical time of the current transaction.\n"
            ]
        },
        "block.timestamp": {
            "prefix": "block.timestamp",
            "body": "block.timestamp",
            "description": [
                "block.timestamp returns (uint64);\n",
                "Returns the starting logical time of the current block.\n"
            ]
        },
        "now": {
            "prefix": "now",
            "body": "now",
            "description": [
                "Example:\nuint start = now;\n",
                "It is the number of seconds since the Epoch.\n"
            ]
        },
        "rnd.next": {
            "prefix": "rnd.next",
            "body": "rnd.next(${1:[Type limit]})",
            "description": [
                "rnd.next([Type limit]) returns (Type);\n",
                "Generates a new pseudo-random number.\n",
                "1. Returns uint256 number.",
                "2. If the first argument limit > 0 then function returns the value in the range 0..limit-1. Else if limit < 0 then the returned value lies in range limit..-1. Else if limit == 0 then it returns 0.\n",
                "Example:\n",
                "// 1)\nuint256 r0 = rnd.next(); // 0..2^256-1",
                "// 2)\nuint8 r1 = rnd.next(100);  // 0..99",
                "int8 r2 = rnd.next(int8(100));  // 0..99",
                "int8 r3 = rnd.next(int8(-100)); // -100..-1\n"
            ]
        },
        "rnd.getSeed": {
            "prefix": "rnd.getSeed",
            "body": "rnd.getSeed()",
            "description": [
                "rnd.getSeed() returns (uint256);\n",
                "Returns the current random seed.\n"
            ]
        },
        "rnd.setSeed": {
            "prefix": "rnd.setSeed",
            "body": "rnd.setSeed(${1:uint256 x})",
            "description": [
                "rnd.setSeed(uint256 x));\n",
                "Sets the random seed to x.\n"
            ]
        },
        "rnd.shuffle": {
            "prefix": "rnd.shuffle",
            "body": "rnd.shuffle(${1:uint someNumber(optional)})",
            "description": [
                "Randomizes the random seed.\n",
                "\n//(1)\nrnd.shuffle(uint someNumber);\n//(2)\nrnd.shuffle();\n",
                "1. Mixes the random seed and someNumber\nrnd.shuffle(uint someNumber);",
                "2. Mixes the random seed and the logical time of the current transaction."
            ]
        },
        "abi.encode": {
            "prefix": "abi.encode",
            "body": "abi.encode(${1:TypeA a}, ${2:TypeB b})",
            "description": [
                "Creates cell from the values.\n",
                "abi.encode(TypeA a, TypeB b, ...) returns (TvmCell /*cell*/);\n",
                "Example:\n",
                "TvmCell cell = abi.encode(uint(1), uint(2), uint(3), uint(4));"
            ]
        },
        "abi.decode": {
            "prefix": "abi.decode",
            "body": "abi.decode(${1:TvmCell}, (${2:TypeA}, ${3:TypeB}))",
            "description": [
                "abi.decode(TvmCell cell, (TypeA, TypeB, ...)) returns (TypeA /*a*/, TypeB /*b*/, ...);",
                "Decodes the cell and returns the values. Note: all types must be set in abi.decode. Otherwise, abi.decode throws an exception.\n",                
                "Example:\n",
                "(uint a, uint b, uint c, uint d) = abi.decode(cell, (uint, uint, uint, uint));"
            ]
        },
        "selfdestruct": {
            "prefix": "selfdestruct",
            "body": "selfdestruct(${1:address dest_addr})",
            "description": [
                "selfdestruct(address dest_addr);\n",
                "Creates and sends the message that carries all the remaining balance of the current smart contract and destroys the current account.\n"
            ]
        },
        "sha256": {
            "prefix": "sha256",
            "body": "sha256(${1|TvmSlice slice, bytes b, string str|})",
            "description": [
                "sha256(TvmSlice slice) returns (uint256)\n",
                "sha256(bytes b) returns (uint256)\n",
                "sha256(string str) returns (uint256)\n",
                "1. Compute the SHA-256 hash. If the bit length of slice is not divisible by eight, throws a cell underflow exception. References of slice are not used to compute the hash. Only data bits located in the root cell of slice are used.  ",
                "2. Compute the SHA-256 hash only for the first 127 bytes. If bytes.length > 127 then b[128], b[129], b[130] ... elements are ignored.",
                "3. Same as for bytes: only the first 127 nbytes are taken into account.\n"
            ]
        },
        "gasToValue": {
            "prefix": "gasToValue",
            "body": "gasToValue(${1:uint128 gas}, ${2:int8 wid})",
            "description": [
                "gasToValue(uint128 gas, int8 wid) returns (uint128 value)\n",
                "Returns worth of gas in workchain wid. Throws an exception if wid doesn't equal 0 and -1.\n"
            ]
        },
        "valueToGas": {
            "prefix": "valueToGas",
            "body": "valueToGas(${1:uint128 value}, ${2:int8 wid})",
            "description": [
                "gasToValue(uint128 value, int8 wid) returns (uint128 gas)\n",
                "Returns how much gas could be bought on value nanoevers in workchain wid. Throws an exception if wid doesn't equal 0 and -1.\n"
            ]
        },
        "constant": {
            "prefix": "constant",
            "body": "constant ${1:name} = ${0:value};",
            "description": [
                "Example: uint constant cost = 100;\n",
                "For constant variables, the value has to be a constant at compile time and this value is substituted where the variable is used. The value has to be assigned where the variable is declared.\n"
            ]
        },
        "static": {
            "prefix": "static",
            "body": "static ${0:name};",
            "description": [
                "Static state variables are used in generation of the contract origin state. Such variables can be set while deploying contract from contract (onchain) or by tvm-linker (offchain).\n",
                "Example:\n",
                "uint static a; //ok\n",
                "uint static b = 123; // error\n"
            ]
        },
        "inline": {
            "prefix": "inline",
            "body": "inline",
            "description": [
                "Instructs the compiler to insert a copy of the function body into each place where the function is called. Keyword can be used only for private and internal functions.\n",
                "Example:\n",
                "// This function is called as usual function.\nfunction getSum(uint a, uint b) public returns (uint) {\n    return sum(a, b);\n}\n\n// Code of this function is inserted to the place of call.\nfunction sum(uint a, uint b) private inline returns (uint) {\n    return a + b;\n}\n"
            ]
        },
        "emptyMap": {
            "prefix": "emptyMap",
            "body": "emptyMap",
            "description": [
                "Keyword emptyMap is a constant that is used to indicate a mapping of arbitrary type without values.\n",
                "Example:\n",
                "\nstruct Stakes {\n    uint total;\n    mapping(uint => uint) stakes;\n}\n\n// create struct with empty mapping 'stakes'\nStakes stakes = Stakes({stakes: emptyMap, total: 200});\n\n"
            ]
        },
        "functionID": {
            "prefix": "functionID",
            "body": "functionID(${1:uint32 ID})",
            "description": [
                "functionID keyword allows setting identifier of the function manually. Each public function has unique 32-bit id. id==0 is reserved for receive function. If functionID is not used then function id is calculated as a hash of the function signature. In general, there is no need to set function id manually.",
                "Example:\n",
                "function f() public pure functionID(123) {\n    /*...*/\n}\n"
            ]
        },
        "externalMsg": {
            "prefix": "externalMsg",
            "body": "externalMsg",
            "description": [
                "Specify which messages the function can handle. If is called by internal message, the function throws an exception with code 71.",
                "Example:\n",
                "function f() public externalMsg { // this function receives only external messages \n    /*...*/\n}\n\n// Note: keyword 'external' specifies function visibility\nfunction ff() external externalMsg { // this function receives only external messages also  \n    /*...*/\n}\n"
            ]
        },
        "internalMsg": {
            "prefix": "internalMsg",
            "body": "internalMsg",
            "description": [
                "Specify which messages the function can handle. If is called by external message, the function throws an exception with code 72.",
                "Example:\n",
                "function g() public internalMsg { // this function receives only internal messages\n    /*...*/\n}\n\n// These function receives internal and external messages.\nfunction fun() public { /*...*/ }\n"
            ]
        },
        "nano": {
            "prefix": "nano",
            "body": "nano",
            "description": [
                "1 nano = 0.000000001 ever or 1e-9 ever\n"
            ]
        },
        "nanoever": {
            "prefix": "nanoever",
            "body": "nanoever",
            "description": [
                "1 nanoever == 0.000000001 ever or 1e-9ton\n"
            ]
        },
        "Ever": {
            "prefix": "Ever",
            "body": "Ever",
            "description": [
                "1 Ever == 1e9 nanoever\n"
            ]
        },
        "micro": {
            "prefix": "micro",
            "body": "micro",
            "description": [
                "1 Ever == 1e-6 ever\n"
            ]
        },
        "microever": {
            "prefix": "microever",
            "body": "microever",
            "description": [
                "1 microever == 1e-6 ever\n"
            ]
        },
        "milli": {
            "prefix": "milli",
            "body": "milli",
            "description": [
                "1 milli == 1e-3 ever\n"
            ]
        },
        "milliever": {
            "prefix": "milliever",
            "body": "milliever",
            "description": [
                "1 milliever == 1e-3 ever\n"
            ]
        },
        "kiloever": {
            "prefix": "kiloever",
            "body": "kiloever",
            "description": [
                "1 kiloever == 1e3 ever\n"
            ]
        },
        "kEver": {
            "prefix": "kEver",
            "body": "kEver",
            "description": [
                "1 kEver == 1e3 ever\n"
            ]
        },
        "megaever": {
            "prefix": "megaever",
            "body": "megaever",
            "description": [
                "1 kEver == 1e6 ever\n"
            ]
        },
        "MEver": {
            "prefix": "MEver",
            "body": "MEver",
            "description": [
                "1 MEver == 1e6 ever\n"
            ]
        },
        "gigaever": {
            "prefix": "gigaever",
            "body": "gigaever",
            "description": [
                "1 gigaever == 1e6 ever\n"
            ]
        },
        "GEver": {
            "prefix": "GEver",
            "body": "GEver",
            "description": [
                "1 GEver == 1e6 ever\n"
            ]
        },        
        "nanoton": {
            "prefix": "nanoton",
            "body": "nanoton",
            "description": [
                "1 nanoton == 0.000000001 ton or 1e-9ton\n"
            ]
        },
        "microton": {
            "prefix": "microton",
            "body": "microton",
            "description": [
                "1 microton == 1e-6 ton\n"
            ]
        },
        "milliton": {
            "prefix": "milliton",
            "body": "milliton",
            "description": [
                "1 milliton == 1e-3 ton\n"
            ]
        },
        "kiloton": {
            "prefix": "kiloton",
            "body": "kiloton",
            "description": [
                "1 kiloton == 1e3 ton\n"
            ]
        },
        "kTon": {
            "prefix": "kTon",
            "body": "kTon",
            "description": [
                "1 kTon == 1e3 ton\n"
            ]
        },
        "megaton": {
            "prefix": "megaton",
            "body": "megaton",
            "description": [
                "1 kTon == 1e6 ton\n"
            ]
        },
        "MTon": {
            "prefix": "MTon",
            "body": "MTon",
            "description": [
                "1 MTon == 1e6 ton\n"
            ]
        },
        "gigaton": {
            "prefix": "gigaton",
            "body": "gigaton",
            "description": [
                "1 gigaton == 1e6 ton\n"
            ]
        },
        "GTon": {
            "prefix": "GTon",
            "body": "GTon",
            "description": [
                "1 GTon == 1e6 ton\n"
            ]
        },
        "<optional(Type)>.set": {
            "prefix": ".set",
            "body": "set(${1:Type value})",
            "description": [
                "<optional(Type)>.set(Type value);\n",
                "Replaces the content of the optional with the contents of other."
            ]
        },
        "<optional(Type)>.reset": {
            "prefix": ".reset",
            "body": "reset()",
            "description": [
                "<optional(Type)>.reset();\n",
                "Deletes the content of the optional."
            ]
        },
        "<TvmSlice>.decode": {
            "prefix": ".decode",
            "body": "decode(${1:TypeA}, ${2:TypeB} ...)",
            "description": [
                "<TvmSlice>.decode(TypeA, TypeB, ...) returns (TypeA a, TypeB b, ...);\n",
                "Supported types: `uintN`, `intN`, `bytesN`, `bool`, `ufixedMxN`, `fixedMxN`, `address`, `contract`, `TvmCell`, `bytes`, `string`, `mapping`, `ExtraCurrencyCollection`, `array`, `optional` and `struct`\n",
                "Example:\n",
                "TvmSlice slice = ...;\n",
                "(uint8 a, uint16 b) = slice.decode(uint8, uint16);\n",
                "(uint16 num0, uint32 num1, address addr) = slice.decode(uint16, uint32, address);"
            ]
        },
        "TvmCell": {
            "prefix": "TvmCell",
            "body": "TvmCell",
            "description": [
                "TvmCell represents TVM cell (TVM - 1.1.3). The compiler defines the following operators and functions to work with this type:\n",
                "Operators:\n",
                " * Comparisons: ==, != (evaluate to bool)\n",
                "Functions:\n",
                " * <TvmCell>.depth()",
                " * <TvmCell>.dataSize()",
                " * <TvmCell>.dataSizeQ()",
                " * <TvmCell>.toSlice()"
            ]
        },
        "TvmSlice": {
            "prefix": "TvmSlice",
            "body": "TvmSlice ${1:name}",
            "description": [
                "TvmSlice represents TVM cell slice (TVM - 1.1.3). The compiler defines the following operators and functions to work with this type:\n",
                "Operators:\n",
                " * Comparisons: <=, <, ==, !=, >=, > (evaluate to bool). Note: only bit data from the root cells are compared, references are ignored.\n",
                "Functions:\n",
                " * <TvmSlice>.empty()",
                " * <TvmSlice>.size()",
                " * <TvmSlice>.dataSize",
                " * <TvmSlice>.dataSizeQ()",
                " * <TvmSlice>.bits()",
                " * <TvmSlice>.refs()",
                " * <TvmSlice>.bitsAndRefs()",
                " * <TvmSlice>.depth()",
                " * <TvmSlice>.hasNBits(), <TvmSlice>.hasNRefs() and <TvmSlice>.hasNBitsAndRefs()",
                " * <TvmSlice>.compare()\n",
                "TvmSlice load primitives:\n",
                " * \t<TvmSlice>.decode()",
                " * \t<TvmSlice>.loadRef()",
                " * \t<TvmSlice>.loadRefAsSlice()",
                " * \t<TvmSlice>.loadSigned()",
                " * \t<TvmSlice>.loadUnsigned()",
                " * \t<TvmSlice>.loadTons()",
                " * \t<TvmSlice>.loadSlice()",
                " * \t<TvmSlice>.decodeFunctionParams()",
                " * \t<TvmSlice>.skip()"
            ]
        },
        "TvmBuilder": {
            "prefix": "TvmBuilder",
            "body": "TvmBuilder ${1:name}",
            "description": [
                "TvmBuilder represents TTVM cell builder (TVM - 1.1.3). The compiler defines the following functions to work with this type:\n",
                " * <TvmBuilder>.toSlice()",
                " * <TvmBuilder>.toCell()",
                " * <TvmBuilder>.bits()",
                " * <TvmBuilder>.refs()",
                " * <TvmBuilder>.bitsAndRefs()",
                " * <TvmBuilder>.remBits()",
                " * <TvmBuilder>.remRefs()",
                " * <TvmBuilder>.remBitsAndRefs()",
                " * <TvmBuilder>.depth()",
                " * <TvmBuilder>.store()",
                " * <TvmBuilder>.storeOnes()",
                " * <TvmBuilder>.storeZeroes()",
                " * <TvmBuilder>.storeSigned()",
                " * <TvmBuilder>.storeUnsigned()",
                " * <TvmBuilder>.storeRef()",
                " * <TvmBuilder>.storeTons()"
            ]
        },
        "AddressInput.get": {
            "prefix": "AddressInput.get",
            "body": "AddressInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\");",
            "description": [
                "Allows to get TON standard address selected by user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback",
                " - prompt: bytes — utf-8 string to print to the user before input.",
                "Returns:",
                " - value: address — address selected by user.",
                "\nExample:",
                "function start() public override {\n    AddressInput.get(tvm.functionId(setAddress), \"Enter wallet address:\");\n}\nfunction setAddress(address value) public pure {\n    // TODO: continue here\n}\n"
            ]
        },
        "AmountInput.get": {
            "prefix": "AmountInput.get",
            "body": "AmountInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:uint8 decimal}, ${4:uint128 min}, ${5:uint128 max});",
            "description": [
                "prints prompt message to the user and returns amount of tokens entered by user.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n - decimal: uint8 - number of decimals used by amount token, e.g. 9 - means that browser should multiply token amount to 1000000000 to get its debot represenation.\n - min: uint128 - minimal amount that can be entered by user.\n - max: uint128 - maximum amount that can be entered by user.\n",
                "Returns:",
                " - { value: uint128 } - amount of tokens multiplied by `10^decimals`. To get the integer part of an amount debot should divide value by `10^decimals`.",
                "\nExample:",
                "function start() public override {\n    AmountInput.get(tvm.functionId(setAmount), \"Enter amount of evers:\",  9, 1e9, 100e9);\n}\nfunction setAmount(uint128 value) public pure {\n    // TODO: continue here\n}"
            ]
        },
        "Base64.encode": {
            "prefix": "Base64.encode",
            "body": "Base64.encode(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\");",
            "description": [
                "Encode Base64 string",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback",
                " - data: bytes — input binary data",
                "Returns:",
                " - base64: string — base64 string",
                "\nExample:",
                "function start() public override {\n    Base64.encode(tvm.functionId(setEncoded), \"abc\");\n}\nfunction setEncoded(string base64) public {\n    require(base64==\"YWJj\",101);\n    Base64.decode(tvm.functionId(setDecoded), base64);\n}\nfunction setDecoded(bytes data) public {\n    require(data==\"abc\",102);\n    // TODO: continue here\n}"
            ]
        },
        "Base64.decode": {
            "prefix": "Base64.decode",
            "body": "Base64.decode(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:string base64}\");",
            "description": [
                "Decode Base64 string",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback",
                " - base64: string — base64 string",
                "Returns:",
                " - data: bytes — output binary data",
                "\nExample:",
                "function start() public override {\n    Base64.encode(tvm.functionId(setEncoded), \"abc\");\n}\nfunction setEncoded(string base64) public {\n    require(base64==\"YWJj\",101);\n    Base64.decode(tvm.functionId(setDecoded), base64);\n}\nfunction setDecoded(bytes data) public {\n    require(data==\"abc\",102);\n    // TODO: continue here\n}"
            ]
        },
        "ConfirmInput.get": {
            "prefix": "ConfirmInput.get",
            "body": "ConfirmInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\");",
            "description": [
                "Prints prompt message to the user and returns true or false choice",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input.\nReturns:\n{ value: bool }\n",
                "Example:\nfunction start() public override {\n    ConfirmInput.get(tvm.functionId(setConfirm), \"Say yes or no:\");\n}\nfunction setConfirm(bool value) public pure {\n    // TODO: continue here\n} "
            ]
        },
        "CountryInput.get": {
            "prefix": "CountryInput.get",
            "body": "CountryInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:string[] permitted}, ${4:string[] banned});",
            "description": [
                "Allows to get the country code entered by the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user before input\n - permitted: string[] - if not empty, list of country codes permitted for input\n - banned: string[] - if not empty, list of country codes banned for input\nReturns:\n - value: string — country code (ISO 3166-1 alpha-2) entered by user\n",
                "Example:\nfunction start() public override {\n    CountryInput.get(tvm.functionId(setCountryCode), \"Enter your country code:\", [], []);\n    // or if Russia, Bulgaria and Cuba permitted for input:\n    // CountryInput.get(tvm.functionId(setCountryCode), \"Enter your country code:\", ['RU', 'BG', 'CU'], []);\n    // or if the drop-down list of countries should not include North Korea and Lebanon\n    // CountryInput.get(tvm.functionId(setCountryCode), \"Enter your country:\", [], ['KP', 'LB']);\n}\nfunction setCountryCode(string value) public pure {\n    // TODO: continue here\n}"
            ]
        },
        "DateTimeInput.getDate": {
            "prefix": "DateTimeInput.getDate",
            "body": "DateTimeInput.getDate(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:int128 defaultDate}, ${4:int128 minDate}, ${5:int128 maxDate});",
            "description": [
                "returns date timestamp selected by user.\nNote: function accepts date in unixtime (seconds from the midnight UTC-0 of 1st Jan 1970) which is int128 bits long, negative values are allowed. Date unixtime includes day, month, year and 0 hours, 0 minutes and 0 seconds.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user before input.\n - defaultDate: int128 - date by default.\n - minDate: int128 - minimum date that can be chosen.\n - maxDate: int128 - maximum date that can be chosen.\nReturns:\n date: int128 - chosen date unixtime (UTC-0).",
                "\nExample:function start() public override {\n    DateTimeInput.getDate(tvm.functionId(setDate),\n        \"Choose a day in 2021 from the begining until current day:\", \n        int128(now), 1609448400, int128(now));\n}\nfunction setDate(int128 date) public {\n    // TODO: continue here\n}"
            ]
        },
        "DateTimeInput.getTime": {
            "prefix": "DateTimeInput.getTime",
            "body": "DateTimeInput.getTime(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:uint32 defaultTime}, ${4:uint32 minTime}, ${5:uint32 maxTime}, ${6:uint8 Interval});",
            "description": [
                "returns the timestamp within a day selected by the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user before input.\n - defaultTime: uint32 — time by default.\n - minTime: uint32 — minimum time that can be chosen.\n - maxTime: uint32 — maximum time that can be chosen.\n - minuteInterval: uint8 - minimal allowed minuteInterval between neibour times in minutes. Valid values are {1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30}.\nReturns:\n time: uint32 — chosen timestamp.",
                "\nExample:DateTimeInput.getTime(tvm.functionId(setTime), \n\"Choose a day time (local):\", \n55800, 55800, 86100, 1);"
            ]
        },
        "DateTimeInput.getDateTime": {
            "prefix": "DateTimeInput.getDateTime",
            "body": "DateTimeInput.getDateTime(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:int128 defaultDatetime}, ${4:int128 minDatetime}, ${5:int128 maxDatetime}, ${6:uint8 minuteInterval}, ${7:int16 inTimeZoneOffset});",
            "description": [
                "allow to select date and time.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n - defaultDatetime:  int128 - unixtime, default date and time.\n - minDatetime: int128 - unixtime, minimum allowed date and time to choose.\n - maxDatetime: int128 - unixtime, maximum allowed date and time to choose.\n - minuteInterval: uint8 - minimal allowed minuteInterval between neibour times in minutes. Valid values are {1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30}.\n - inTimeZoneOffset: int16 - time zone offset related to UTC-0 in minutes. There is a special value 0x7FFF which defines local user time zone.\nReturns:\n datetime: int128 - unixtime of chozen date and time.\n - timeZoneOffset: int16 - time zone offset in minutes. Use this value for correct date and time representation for the user.\n "
            ]
        },
        "DateTimeInput.getTimeZoneOffset": {
            "prefix": "DateTimeInput.getTimeZoneOffset",
            "body": "DateTimeInput.getTimeZoneOffset(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "returns user time zone offset in minutes.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\nReturns:\n timeZoneOffset: int16 - user time zone offset in minutes."
            ]
        },
        "EncryptionBoxInput.getNaclSecretBox": {
            "prefix": "EncryptionBoxInput.getNaclSecretBox",
            "body": "EncryptionBoxInput.getNaclSecretBox(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes nonce});",
            "description": [
                "Prints prompt message to the user and returns handle to opened Nacl secret box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input, OPTIONAL (empty string is similar to null).\n - nonce: bytes — bytes of nonce.\nReturns:\n - handle: uint32 — id of registered encryption box.\n"
            ]
        },
        "EncryptionBoxInput.getNaclBox": {
            "prefix": "EncryptionBoxInput.getNaclBox",
            "body": "EncryptionBoxInput.getNaclBox(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes nonce}, ${4:uint256 theirPubkey});",
            "description": [
                "Prints prompt message to the user and returns handle to Nacl box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input, OPTIONAL (empty string is similar to null).\n - nonce: bytes — bytes of nonce.\n - theirPubkey: uinit256 - receiver's public key.\nReturns:\n - handle: uint32 — id of registered encryption box.\n "
            ]
        },
        "EncryptionBoxInput.getChaCha20Box": {
            "prefix": "EncryptionBoxInput.getChaCha20Box",
            "body": "EncryptionBoxInput.getChaCha20Box(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes nonce});",
            "description": [
                "Prints prompt message to the user and returns handle to ChaCha20 box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input, OPTIONAL (empty string is similar to null).\n - nonce: bytes — 96-bit nonce.\nReturns:\n - handle: uint32 — id of registered encryption box.\n"
            ]
        },
        "EncryptionBoxInput.remove": {
            "prefix": "EncryptionBoxInput.remove",
            "body": "EncryptionBoxInput.remove(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 handle});",
            "description": [
                "Removes encryption box handle from Browser and destroys underlying Encryption Box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - handle: uint32 — encryption box handle to remove. This handle becomes invalid after removing.\nReturns:\n - removed: bool - true if handle was found and successfully removed. Otherwise false.\n "
            ]
        },
        "EncryptionBoxInput.getSupportedAlgorithms": {
            "prefix": "EncryptionBoxInput.getSupportedAlgorithms",
            "body": "EncryptionBoxInput.getSupportedAlgorithms(tvm.functionId(${1:setAlgorithms}));",
            "description": [
                "Returns a list of algorithms supported by DeBot Browser.",
                "Returns: names: bytes[] — array of algorithm names supported by DeBot Browser."
            ]
        },
        "Hex.encode": {
            "prefix": "Hex.encode",
            "body": "Hex.encode(tvm.functionId(${1:uint32 callbackFunctionId}),${2:bytes data});",
            "description": [
                "Encode data to hex format.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - data: bytes — input binary data.\nReturns:\n - hexstr: string — hex string\n",
                "Example:\nbytes data = bytes(\"aaa\");\nHex.encode(tvm.functionId(setEncode), data);"
            ]
        },
        "Hex.decode": {
            "prefix": "Hex.decode",
            "body": "Hex.decode(tvm.functionId(${1:uint32 callbackFunctionId}),${2:string hexstr});",
            "description": [
                "Decode string from base64 format.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - hexstr: string — hex string.\nReturns:\n - data: bytes — output binary data\n",
                "Example:\nstring hexstr = \"616161\";\n Hex.decode(tvm.functionId(setDecode), hexstr);"
            ]
        },
        "Json.deserialize": {
            "prefix": "Json.deserialize",
            "body": "Json.deserialize(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:string json});",
            "description": [
                "Deserialize json into the structure.",
                "\nArguments:",
                "answerId: uint32 — function id of result callback. Callback function should have two input parameters: \"result\" of type bool and \"obj\" of type <StructName>.\n - json: string — json utf8 string.\nReturns:\n - result: bool - result of operation:\n    true - operation succeeded;\n    false - operation failed.\n - obj: <StructName> - deserialised json into structure of type <StructName>\nNote: type of obj parameter is set by StructName input parameter. And input parameters of answerId function should have two input parameters: \"result\" of type bool and \"obj\" of type StructName.\n "
            ]
        },
        "Media.output": {
            "prefix": "Media.output",
            "body": "Media.output(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes data});",
            "description": [
                "Allows to show media of different formats (images, docs and others) to the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user on top of media.\n - data: bytes — utf-8 string with encoded media according to [RFC2397](https://datatracker.ietf.org/doc/html/rfc2397).\nReturns:\nMediaStatus - status of media output.",
                "Example:\nMedia.output(tvm.functionId(setResult), \"PNG image\", format(\"data:image/png;base64,{}\", m_pngBase64));\n//=>function setResult(MediaStatus result);"
            ]
        },
        "MediaStatus.Success": {
            "prefix": "MediaStatus.Success",
            "body": "MediaStatus.Success",
            "description": ""
        },
        "MediaStatus.UnsupportedMediaType": {
            "prefix": "MediaStatus.UnsupportedMediaType",
            "body": "MediaStatus.UnsupportedMediaType",
            "description": ""
        },
        "MediaStatus.InvalidDataScheme": {
            "prefix": "MediaStatus.InvalidDataScheme",
            "body": "MediaStatus.InvalidDataScheme",
            "description": ""
        },
        "Media.getSupportedMediaTypes": {
            "prefix": "Media.getSupportedMediaTypes",
            "body": "Media.getSupportedMediaTypes(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Returns array of supported media types.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\nReturns:\nmediaTypes: bytes[] — array of strings with supported media types. Each string is in the format of \"type/subtype\". E.g. [\"image/png\", \"image/jpg\"]."
            ]
        },
        "Menu.select": {
            "prefix": "Menu.select",
            "body": "Menu.select(${1:bytes title}, ${2:bytes description}, [\n\tMenuItem(${3:bytes title}, ${4:string description}, tvm.functionId(${5:handleMenu1}))\n]);",
            "description": [
                "Prints prompt message to the user and returns string entered by user.",
                "\nArguments:",
                " - title: bytes — utf8 string with menu title.\n - description: bytes — utf8 string with a description of a menu. Optional, can be `\"\"` (empty string).\n - items: MenuItem[] - array of menu items.\nReturns:\nindex: uint32 — index of selected menu item starting from 0.",
                "MenuItem { title: bytes — utf8 string with a short name of menu item. description: string — utf8 string describing details of menu item. Optional, can be \"\" (empty string). handlerId: uint32 — id of a callback function to be called when this item is selected. }",
                "Example:\n function _menu() private inline {\n    Menu.select(\"Main menu\", \"description for menu\", [\n        MenuItem(\"menu 1\", \"\", tvm.functionId(handleMenu1)),\n        MenuItem(\"menu 2\", \"desc for menu 2\", tvm.functionId(handleMenu2))\n    ]);\n}\n "
            ]
        },
        "MenuItem": {
            "prefix": "MenuItem",
            "body": "MenuItem(${1:bytes title}, ${2:string description}, tvm.functionId(${3:handleMenu1}));",
            "description": [
                "MenuItem { title: bytes — utf8 string with a short name of menu item. description: string — utf8 string describing details of menu item. Optional, can be \"\" (empty string). handlerId: uint32 — id of a callback function to be called when this item is selected. }"
            ]
        },
        "Network.get": {
            "prefix": "Network.get",
            "body": "Network.get(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes url}, ${3:bytes[] headers});",
            "description": [
                "Load data from the server using an HTTP GET request.",
                "\nArguments:",
                " - answerId: uint32 — id of callback function.\n - url: bytes — utf8 string with the name of the resource that you wish to fetch.\n - headers: bytes[] — array of utf8 strings with HTTP headers that you want to add to your request.\nReturns:\n - statusCode: int32 - response status code.\n - retHeaders: string[] - array of utf8 strings with response headers.\n - content: string — response body as utf8 string.\n"
            ]
        },
        "Network.post": {
            "prefix": "Network.post",
            "body": "Network.post(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes url}, ${3:bytes[] headers}, ${4:bytes body});",
            "description": [
                "Send data to the server using an HTTP POST request.",
                "\nArguments:",
                " - answerId: uint32 — id of callback function.\n - url: bytes — utf8 string with the name of the resource that you wish to fetch.\n - headers: bytes[] — array of utf8 strings with HTTP headers that you want to add to your request.\n - body: bytes — utf8 string with HTTP request body.\nReturns:\n- statusCode: int32 - response status code.\n- retHeaders: string[] - array of utf8 strings with response headers.\n- content: string — response body as utf8 string.\n"
            ]
        },
        "NumberInput.get": {
            "prefix": "NumberInput.get",
            "body": "NumberInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:int256 min}, ${4:int256 max});",
            "description": [
                "Interface for number input.",
                "\nArguments:",
                " - answerId: uint32 — id of callback function.\n - prompt: bytes — utf-8 string to print to the user before input.\n - min: int256 - minimal value allowed to input.\n - max: int256 - maximum value allowed to input.\nReturns:\n- { value: int256 }",
                "\nExample:function start() public override {\n    NumberInput.get(tvm.functionId(setNumber), \"Enter number:\", -10, 100);\n}n - $1function setNumber(int256 value) public pure {\n    // TODO: continue here\n}\n"
            ]
        },
        "QRCode.read": {
            "prefix": "QRCode.read",
            "body": "QRCode.read(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt});",
            "description": [
                "Scans qrcode by camera or from image and returns its decoded data as string.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - prompt: bytes — utf-8 string with message to the user. Optional, empty string \"\" is treated like null.\nReturns:\nvalue: bytes — utf8 string with qrcode data.\nresult: uint8 — one of the `QRStatus` value. `Success` on success.",
                "\nExample:function start() public override {\n    NumberInput.get(tvm.functionId(setNumber), \"Enter number:\", -10, 100);\n}n - $1function setNumber(int256 value) public pure {\n    // TODO: continue here\n}\n"
            ]
        },
        "QRCode.draw": {
            "prefix": "QRCode.draw",
            "body": "QRCode.draw(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes text});",
            "description": [
                "Prints text as QR Code to the user.\nNote: DeBot Browsers can manually choose data correction level.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - prompt: bytes — utf-8 string with message to the user. Optional, empty string \"\" is treated like null.\n - text: bytes — utf-8 string to print as QRCode.\nReturns:\nresult: uint8 — one of the `QRStatus` value. `Success` on success and `ScannerError` on error.\nenum QRStatus { Success = 0, DataTooLong = 1, InvalidCharacter = 2, ScannerError = 3, Canceled = 4, NotSupported = 5 }",
                "\nExample: QRCode.draw(tvm.functionId(setDrawResult), \"DeBot address\", format(\"{}\", address(this)));\n//=>function setDrawResult(QRStatus result)"
            ]
        },
        "QueryStatus.Success": {
            "prefix": "QueryStatus.Success",
            "body": "QueryStatus.Success",
            "description": ""
        },
        "QueryStatus.FilterError": {
            "prefix": "QueryStatus.FilterError",
            "body": "QueryStatus.FilterError",
            "description": ""
        },
        "QueryStatus.NetworkError": {
            "prefix": "QueryStatus.NetworkError",
            "body": "QueryStatus.NetworkError",
            "description": ""
        },
        "QueryStatus.UnknownError": {
            "prefix": "QueryStatus.UnknownError",
            "body": "QueryStatus.UnknownError",
            "description": ""
        },
        "QueryStatus.VariablesError": {
            "prefix": "QueryStatus.VariablesError",
            "body": "QueryStatus.VariablesError",
            "description": ""
        },
        "SortDirection.Ascending": {
            "prefix": "SortDirection.Ascending",
            "body": "SortDirection.Ascending",
            "description": ""
        },
        "SortDirection.Descending": {
            "prefix": "SortDirection.Descending",
            "body": "SortDirection.Descending",
            "description": ""
        },
        "Query.collection": {
            "prefix": "Query.collection",
            "body": "Query.collection(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint8 collectionType}, ${3:bytes queryFilter}, ${4:bytes returnFilter}, ${5:uint32 limit}, ${6:orderBy QueryOrderBy});",
            "description": [
                "Makes a query to blockchain with a certain filter.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - collectionType: uint8 — one of the \"CollectionType\" variants: \n    Accounts (0), Messages (1), Transactions(2). \n - queryFilter: bytes — utf-8 string with object query.\n - returnFilter: bytes — utf-8 string with object query.\n - limit: uint32 — maximum number of objects that can be returned in result array.\n - orderBy: QueryOrderBy — structure that defines sorting rules for returning objects.\n \n Returns:\n - status: uint8 — one of the \"QueryStatus\" variants.\n - objects: JsonLib.Value[] — array of json values. Every json value represents fields requested in \"returnFilter\" for certain \"CollectionType\" variant: message, transaction, account.\n"
            ]
        },
        "Query.waitForCollection": {
            "prefix": "Query.waitForCollection",
            "body": "Query.waitForCollection(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint8 collectionType}, ${3:string queryFilter}, ${4:string returnFilter}, ${5:uint32 timeout});",
            "description": [
                "Returns an object that fulfills the conditions or waits for its appearance.",
                "\nArguments:",
                "\n - answerId: uint32 - id of function callback.\n - collectionType: uint8 - one of the `CollectionType` variants: \n    Accounts (0), Messages (1), Transactions(2). \n    See Query.sol for details.\n - queryFilter: string - utf-8 string with collection filter.\n - returnFilter: string - utf-8 string with projection (result) string.\n - timeout: uint32 - query timeout in ms.\n\n returns:\n \n- status: uint8 - one of the `QueryStatus` variants. See `Query.sol` for details.\n- object: JsonLib.Value - json value with fields requested in `returnFilter` for certain `CollectionType` variant: message, transaction, account.\n"
            ]
        },
        "Query.query": {
            "prefix": "Query.query",
            "body": "Query.query(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:string query}, ${3:string variables});",
            "description": [
                "Performs DAppServer GraphQL query and returns result provided by DAppServer.",
                "\nArguments:",
                "\n - answerId: uint32 - id of function callback.\n - query: string - GraphQL query text.\n - variables: string - Variables used in query.\n\nReturns:\n\n - status: uint8 - one of the `QueryStatus` variants. See `Query.sol` for details.\n - object: JsonLib.Value - json value provided by DAppServer.\n"
            ]
        },
        "QueryOrderBy": {
            "prefix": "QueryOrderBy",
            "body": "QueryOrderBy(${1:string F.E.:created_lt}, ${2:SortDirection});",
            "description": [
                "Example:\n",
                "QueryOrderBy(\"created_lt\", SortDirection.Ascending));\n"
            ]
        },
        "QueryCollection.Messages": {
            "prefix": "QueryCollection.Messages",
            "body": "QueryCollection.Messages",
            "description": [
                "Example:\n",
                "function onGetter(Recipient[] recipients) public {    \n    m_limit = 3;\n    Query.collection(\n        tvm.functionId(setQueryResult), \n        QueryCollection.Messages, \n        format(\"{\"src\":{\"eq\":\"{}\"},\"msg_type\":{\"eq\":0}}\", address(this)),\n        \"created_lt value dst body\",\n        m_limit,\n        QueryOrderBy(\"created_lt\", SortDirection.Ascending)\n    );\n}\n\nfunction setQueryResult(QueryStatus status, JsonLib.Value[] objects) public {\n    if (status != QueryStatus.Success) {\n        Terminal.print(tvm.functionId(Debot.start), \"Messages query failed.\");\n        return;\n    }\n}    \n"
            ]
        },
        "QueryCollection.Accounts": {
            "prefix": "QueryCollection.Accounts",
            "body": "QueryCollection.Accounts",
            "description": ""
        },
        "QueryCollection.Transactions": {
            "prefix": "QueryCollection.Transactions",
            "body": "QueryCollection.Transactions",
            "description": ""
        },
        "Sdk.getBalance": {
            "prefix": "Sdk.getBalance",
            "body": "Sdk.getBalance(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:address addr});",
            "description": ""
        },
        "Sdk.getAccountType": {
            "prefix": "Sdk.getAccountType",
            "body": "Sdk.getAccountType(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:address addr});",
            "description": [
                "Get account type",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - addr    : address — address of contract.\nReturns:\n - acc_type: int8 - account type. Valid values are -1 (unexist), 0 (uninit), 1 (active), 2 (frozen).\n"
            ]
        },
        "Sdk.getAccountCodeHash": {
            "prefix": "Sdk.getAccountCodeHash",
            "body": "Sdk.getAccountCodeHash(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:address addr});",
            "description": [
                "Get account code hash.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - addr    : address — smart contract address.\nReturns:\n - code_hash: uint256 - account code hash.\n"
            ]
        },
        "Sdk.encrypt": {
            "prefix": "Sdk.encrypt",
            "body": "Sdk.encrypt(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 boxHandle});",
            "description": [
                "Encrypt data with defined encryption box.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - boxHandle: uint32 — encryption box handle. Remark: it can be received through 'EncryptionBoxInput' interface.\nReturns:\n - result: uint32 — result code of operation. 0 if succeeded, otherwise SDK error code.\n - encrypted: bytes — encrypted data bytes.\n"
            ]
        },
        "Sdk.decrypt": {
            "prefix": "Sdk.decrypt",
            "body": "Sdk.decrypt(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 boxHandle});",
            "description": [
                "Decrypt data with defined encryption box.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - boxHandle: uint32 — encryption box handle. Remark: it can be received through 'EncryptionBoxInput' interface.\nReturns:\n - result: uint32 — result code of operation. 0 if succeeded, otherwise SDK error code.\n - decrypted: bytes — decrypted data bytes.\n"
            ]
        },
        "Sdk.signHash": {
            "prefix": "Sdk.signHash",
            "body": "Sdk.signHash(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 boxHandle}, ${3:uint256 hash});",
            "description": [
                "Sign data hash (256bits) with defined signing box.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - boxHandle: uint32 — signing box handle.\n - hash: uint256 — data hash to sign.\nReturns:\n- signature: bytes — 512 bits of signature.\n"
            ]
        },
        "Sdk.genRandom": {
            "prefix": "Sdk.genRandom",
            "body": "Sdk.genRandom(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 length});",
            "description": [
                "Generate random byte array of the specified length.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - length: uint32 — size of random byte array.\nReturns:\n - buffer: bytes — random bytes.\n"
            ]
        },
        "Sdk.substring": {
            "prefix": "Sdk.substring",
            "body": "Sdk.substring(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes str}, ${3:uint32 start}, ${4:uint32 count});",
            "description": [
                "Return string of count bytes starting from start byte of original string.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - str: bytes — original string.\n - start: uint32 — index of byte in original string from which to start substring. 'start' must be less then length of original string.\n - count: uint32 — length in bytes of substring. Must be less or equal then ( 'str.legnth' - 'start' ).\nReturns:\nsubstr: bytes — substring of original string.\n "
            ]
        },
        "SecurityCardManagement.getBlockHashes": {
            "prefix": "SecurityCardManagement.getBlockHashes",
            "body": "SecurityCardManagement.getBlockHashes(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get H2, H3 hashes and serial number from security card. The browser should call getHashes function from the security card library to get H2, H3 and serial number. This will not work if the card applet has the status: \"TonWalletApplet is personalized.\"\n",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n\nReturns:\n\n- h2: uint256 - H2 hash\n- h3: uint256 - H3 hash\n- sn: uint192 — card serial number\n"
            ]
        },
        "SecurityCardManagement.turnOnWallet": {
            "prefix": "SecurityCardManagement.turnOnWallet",
            "body": "SecurityCardManagement.turnOnWallet(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint192 sn}, ${3:bytes p1}, ${4:bytes iv}, ${5:bytes cs});",
            "description": [
                "Verify and setup security card initial data. Before forwarding the request to a security card, a browser must request a pin code and send it to the card with other data.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - sn      : uint192 — card serial number\n - p1      : bytes — authentication password (128 bytes)\n - iv      : bytes — vector for AES128 CBC initialization for encrypting P1 (16 bytes)\n - cs      : bytes — common secret(32 bytes)\n\nReturns:\n\n- pubkey: uint256 - security card public key\n"
            ]
        },
        "SecurityCardManagement.setRecoveryData": {
            "prefix": "SecurityCardManagement.setRecoveryData",
            "body": "SecurityCardManagement.setRecoveryData(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes recoveryData});",
            "description": [
                "Set recovery data to security card",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - recoveryData : bytes — recovery data\n\nReturns:\n\n- result: bool - result of operation\n"
            ]
        },
        "SecurityCardManagement.getRecoveryData": {
            "prefix": "SecurityCardManagement.getRecoveryData",
            "body": "SecurityCardManagement.getRecoveryData(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get recovery data from security card",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n - recoveryData : bytes — recovery data.\n"
            ]
        },
        "SecurityCardManagement.getSerialNumber": {
            "prefix": "SecurityCardManagement.getSerialNumber",
            "body": "SecurityCardManagement.getSerialNumber(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get serial number of touched card",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n - serialNumber : uint192 — card serial number.\n"
            ]
        },
        "SecurityCardManagement.getCardList": {
            "prefix": "SecurityCardManagement.getCardList",
            "body": "SecurityCardManagement.getCardList(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get the list of serial numbers of the user's cards for which we have keys in Android keystore/iOS keychain. The browser should call getAllSerialNumbers function from the security card library to get the list of serial numbers of the cards.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\nlist : uint192[] - array of serial numbers of the cards\n"
            ]
        },
        "SecurityCardManagement.deleteCard": {
            "prefix": "SecurityCardManagement.deleteCard",
            "body": "SecurityCardManagement.deleteCard(tvm.functionId(${1:uint32 callbackFunctionId}, ${2:uint192 sn}));",
            "description": [
                "Delete key for given serialNumber from Android keystore/iOS keychain. The browser should call deleteKeyForHmac function from the security card library to get operation execution status (and finishDeleteKeyFromKeyChainAfterInterruption function if it is necessary).\n",
                "Arguments:\n\nanswerId: uint32 - function id of result callback\nsn:       uint192 - serial number of the card for checking\nreturns:\n\nresult: bool - result of operation\n"
            ]
        },
        "SecurityCardManagement.getTonWalletAppletState": {
            "prefix": "SecurityCardManagement.getTonWalletAppletState",
            "body": "SecurityCardManagement.getTonWalletAppletState(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get card applet state.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n - state : string — result of operation.\n"
            ]
        },
        "SecurityCardManagement.getPublicKey": {
            "prefix": "SecurityCardManagement.getPublicKey",
            "body": "SecurityCardManagement.getPublicKey(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes p1}, ${3:bytes cs}, ${4:uint192 sn});",
            "description": [
                "Allows to get the public key of the card\n",
                "Arguments:\n\nanswerId: uint32 - function id of result callback\nreturns:\n\npubkey: uint256 - public key of the card\n"
            ]
        },
        "SecurityCardManagement.isCardExists": {
            "prefix": "SecurityCardManagement.isCardExists",
            "body": "SecurityCardManagement.isCardExists(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint192 sn});",
            "description": [
                "Checks whether the key for this serial number exists in the Android keystore/iOS keychain. The browser should call\n",
                "Arguments:\n\nanswerId: uint32 - function id of result callback\nsn:       uint192 - serial number of the card for checking\nreturns:\n\nresult: bool - result of operation\n"
            ]
        },
        "SecurityCardManagement.createKeyForHmac": {
            "prefix": "SecurityCardManagement.createKeyForHmac",
            "body": "SecurityCardManagement.createKeyForHmac(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes p1}, ${3:bytes cs}, ${4:uint192 sn});\n",
            "description": [
                "Create secret key for HMAC SHA256. This key is saved into Android keystore or iOS keychain and then is used by the app to sign APDU commands data fields.",
                "\nArguments:",
                " - answerId: uint32  - function id of result callback\n - p1:       bytes   - authentication password (128 bytes) \n - cs:       bytes   - common secret(32 bytes)\n - sn:       uint192 — card serial number\nReturns: void.\n"
            ]
        },
        "SigningBoxInput.get": {
            "prefix": "SigningBoxInput.get",
            "body": "SigningBoxInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:uint256 possiblePublicKeys});",
            "description": [
                "Prints prompt message to the user and returns handle for selected SigningBox.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n - possiblePublicKeys: uint256[] - keys for identification of signing box. Can be empty.\nReturns:\n{ handle: uint32 }\n",
                "Example:\n",
                "function start() public override {\n    SigningBoxInput.get(tvm.functionId(setSigningBoxHandle), \"Enter my signing keys:\", [tvm.pubkey()]);\n}\nfunction setSigningBoxHandle(uint32 handle) public {\n    Terminal.print(0, format(\"Signing Box Handle: {}\", handle));\n}\n"
            ]
        },
        "Terminal.input": {
            "prefix": "Terminal.input",
            "body": "Terminal.input(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bool multiline});",
            "description": [
                "Prints prompt message to the user and returns string entered by user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — string printed to the user and describing what to enter\n - multiline: bool - allow multiline text input\nReturns:\n - value: bytes — utf8 string entered by user.\n"
            ]
        },
        "Terminal.print": {
            "prefix": "Terminal.print",
            "body": "Terminal.print(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes message});",
            "description": [
                "Shows string message to the user",
                "\nArguments:",
                " - answerId: uint32 — function id of callback, can be 0.\n - message: bytes — utf8 string as byte array\nReturns: void\n",
                "Example:\n",
                "Terminal.print(0, format(\"Hello {}\", \"World\"));"
            ]
        },
        "Terminal.printf": {
            "prefix": "Terminal.printf",
            "body": "Terminal.printf(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes fmt}, ${3:cell fargs});",
            "description": [
                "Shows formatted string message to the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of callback, can be 0.\n - fmt: bytes — utf8 string as byte array that must be printed to the user\n - fargs: cell - cell with serialized format arguments that must be inserted into 'format' string replacing format specifiers (subsequences between '{}' brackets).\nFormat specifier is one of ABI type like '{int32}', '{address}', '{cell}', '{uint256[]}' and so on or one of the following types:\n - '{utime}' - prints unixtime in UTC date time format. Format argument is an 'uint32' integer.\n    - '{ton}' - prints number of evers in 'decimal.float' format with 9 digits after '.'.\nReturns: void\n",
                "Example:\n",
                "function formatPrint() public {\n    TvmBuilder b;\n    b.store(int8(1), uint32(10));\n    Terminal.printf(0, \"Enter number beetween {int8} and {uint32}\", b.toCell());\n}\n"
            ]
        },
        "UserInfo.getAccount": {
            "prefix": "UserInfo.getAccount",
            "body": "UserInfo.getAccount(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Allows DeBots to receive TON address of user main account. Method should be implemented without user interaction if possible. Otherwise DeBot Browser should ask user to enter TON address of smart contract which can be considered the main user account. If user has no default account then zero address should be used.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\nReturns:\n- value: address — TON address of main user account.\n"
            ]
        },
        "UserInfo.getPublicKey": {
            "prefix": "UserInfo.getPublicKey",
            "body": "UserInfo.getPublicKey(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Allows DeBots to receive user default public key. Method should be implemented without user interaction if possible. If user has no default public key then the method should return 0.",
                "\nArguments:",
                " - answerId: uint32 — function id of callback.\nReturns:\n - value: uint256 - user default public key, can be 0.\n"
            ]
        },
        "UserInfo.getSigningBox": {
            "prefix": "UserInfo.getSigningBox",
            "body": "UserInfo.getSigningBox(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Allows DeBot to receive handle to keypair which can be used to sign external messages to the address returned by UserInfo.getAccount. This function can return zero handle. In that case DeBot should not use it to sign messages and should implement other ways to recevie signing keypair (e.g using SigningBoxHandle interface or delegate DEngine to receive signing box from browser).",
                "\nArguments:",
                " - answerId: uint32 — function id of callback.\nReturns:\n - handle: uint32 — handle to signing keypair, can be 0.\n"
            ]
        },
        "import debot": {
            "prefix": "import debot",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/debots/main/Debot.sol\";",
            "description": ""
        },
        "import AddressInput": {
            "prefix": "import AddressInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/AddressInput/AddressInput.sol\";",
            "description": ""
        },
        "import AmountInput": {
            "prefix": "import AmountInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/AmountInput/AmountInput.sol\";",
            "description": ""
        },
        "import Base64": {
            "prefix": "import Base64",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Base64/Base64.sol\";",
            "description": ""
        },
        "import ConfirmInput": {
            "prefix": "import ConfirmInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/ConfirmInput/ConfirmInput.sol\";",
            "description": ""
        },
        "import CountryInput": {
            "prefix": "import CountryInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/CountryInput/CountryInput.sol\";",
            "description": ""
        },
        "import DateTimeInput": {
            "prefix": "import DateTimeInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/DateTimeInput/DateTimeInput.sol\";",
            "description": ""
        },
        "import EncryptionBoxInput": {
            "prefix": "import EncryptionBoxInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/EncryptionBoxInput/EncryptionBoxInput.sol\";",
            "description": ""
        },
        "import Hex": {
            "prefix": "import Hex",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Hex/Hex.sol\";",
            "description": ""
        },
        "import Media": {
            "prefix": "import Media",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Media/Media.sol\";",
            "description": ""
        },
        "import Menu": {
            "prefix": "import Menu",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Menu/Menu.sol\";",
            "description": ""
        },
        "import Network": {
            "prefix": "import Network",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Network/Network.sol\";",
            "description": ""
        },
        "import NumberInput": {
            "prefix": "import NumberInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/NumberInput/NumberInput.sol\";",
            "description": ""
        },
        "import QRCode": {
            "prefix": "import QRCode",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/QRCode/QRCode.sol\";",
            "description": ""
        },
        "import Query": {
            "prefix": "import Query",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Query/Query.sol\";",
            "description": ""
        },
        "import SecurityCardManagement": {
            "prefix": "import SecurityCardManagement",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/SecurityCardManagement/SecurityCardManagement.sol\";",
            "description": ""
        },
        "import SigningBoxInput": {
            "prefix": "import SigningBoxInput",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/SigningBoxInput/SigningBoxInput.sol\";",
            "description": ""
        },
        "import Terminal": {
            "prefix": "import Terminal",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Terminal/Terminal.sol\";",
            "description": ""
        },
        "import UserInfo": {
            "prefix": "import UserInfo",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/UserInfo/UserInfo.sol\";",
            "description": ""
        },
        "import Sdk": {
            "prefix": "import Sdk",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Sdk/Sdk.sol\";",
            "description": ""
        },
        "import Json": {
            "prefix": "import Json",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Json/Json.sol\";",
            "description": ""
        },
        "import JsonLib": {
            "prefix": "import JsonLib",
            "body": "import \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/libraries/JsonLib.sol\";",
            "description": ""
        },
        "function getDebotInfo": {
            "prefix": "function getDebotInfo",
            "body": "function getDebotInfo() public functionID(0xDEB) override view returns(\n    string name, string version, string publisher, string key, string author,\n    address support, string hello, string language, string dabi, bytes icon\n) {\n    name = \"${1:Test DeBot}\";\n    version = \"${2:0.0.1}\";\n    publisher = \"${3:publisher name}\";\n    key = \"${4:How to use}\";\n    author = \"${5:Author name}\";\n    support = address.makeAddrStd(0, 0x${6:000000000000000000000000000000000000000000000000000000000000});\n    hello = \"${7:Hello, i am an test DeBot.}\";\n    language = \"${8:en}\";\n    dabi = m_debotAbi.get();\n    icon = ${9:''};\n}\n",
            "description": ""
        },
        "function getRequiredInterfaces": {
            "prefix": "function getRequiredInterfaces",
            "body": "function getRequiredInterfaces() public view override returns (uint256[] interfaces) {\n    return [ ${1:ExampleInterface.ID} ];\n}\n",
            "description": ""
        },
        "function start": {
            "prefix": "function start",
            "body": "function start() public override {\n    \n}\n",
            "description": ""
        },
        "function setIcon": {
            "prefix": "function setIcon",
            "body": "function setIcon(bytes icon) public {\n        require(msg.pubkey() == tvm.pubkey(), 100);\n        tvm.accept();\n        m_icon = icon;\n    }\n",
            "description": ""
        },
        "function getInvokeMessage": {
            "prefix": "function getInvokeMessage",
            "body": "function getInvokeMessage(type paramName) public pure\n    returns(TvmCell message) {\n        TvmCell body = tvm.encodeBody(debotName.funcName, paramName);\n        TvmBuilder message_;\n        message_.store(false, true, true, false, address(0), address(this));\n        message_.storeTons(0);\n        message_.storeUnsigned(0, 1);\n        message_.storeTons(0);\n        message_.storeTons(0);\n        message_.store(uint64(0));\n        message_.store(uint32(0));\n        message_.storeUnsigned(0, 1);\n        message_.storeUnsigned(1, 1);\n        message_.store(body);\n        message = message_.toCell();\n}\n",
            "description": "Template for generating invoke messages in debots. See more https://github.com/freeton20/contract-samples/tree/main/invokerDebot"
        },
        "debot template": {
            "prefix": "debot template",
            "body": "pragma ton-solidity >=0.57.0;\npragma AbiHeader expire;\npragma AbiHeader time;\npragma AbiHeader pubkey;\nimport \"https://raw.githubusercontent.com/tonlabs/debots/main/Debot.sol\";\nimport \"https://raw.githubusercontent.com/tonlabs/DeBot-IS-consortium/main/Terminal/Terminal.sol\";\n\ncontract ${1:Name} is Debot{\n\n    function start() public override {       \n    }\n    \n    function getDebotInfo() public functionID(0xDEB) override view returns(\n        string name, string version, string publisher, string key, string author,\n        address support, string hello, string language, string dabi, bytes icon\n    ) {\n        name = \"Test DeBot\";\n        version = \"0.0.1\";\n        publisher = \"publisher name\";\n        key = \"How to use\";\n        author = \"Author name\";\n        support = address.makeAddrStd(0, 0x000000000000000000000000000000000000000000000000000000000000);\n        hello = \"Hello, i am an test DeBot.\";\n        language = \"en\";\n        dabi = m_debotAbi.get();\n        icon = '';\n    }\n    \n    function getRequiredInterfaces() public view override returns (uint256[] interfaces) {\n        return [ Terminal.ID ];\n    }     \n}\n",
            "description": ""
        },
        "int": {
            "prefix": "int",
            "body": "int",
            "description": ""
        },
        "int8": {
            "prefix": "int8",
            "body": "int8",
            "description": ""
        },
        "int16": {
            "prefix": "int16",
            "body": "uint16",
            "description": ""
        },
        "int32": {
            "prefix": "int32",
            "body": "int32",
            "description": ""
        },
        "int64": {
            "prefix": "int64",
            "body": "uint64",
            "description": ""
        },
        "int128": {
            "prefix": "int128",
            "body": "int128",
            "description": ""
        },
        "int256": {
            "prefix": "int256",
            "body": "int256",
            "description": ""
        },
        "uint": {
            "prefix": "uint",
            "body": "uint",
            "description": ""
        },
        "uint8": {
            "prefix": "uint8",
            "body": "uint8",
            "description": ""
        },
        "uint16": {
            "prefix": "uint16",
            "body": "uint16",
            "description": ""
        },
        "uint32": {
            "prefix": "uint32",
            "body": "uint32",
            "description": ""
        },
        "uint64": {
            "prefix": "uint64",
            "body": "uint64",
            "description": ""
        },
        "uint128": {
            "prefix": "uint128",
            "body": "uint128",
            "description": ""
        },
        "uint256": {
            "prefix": "uint256",
            "body": "uint256",
            "description": ""
        },
        "varInt16": {
            "prefix": "varInt16",
            "body": "varInt16",
            "description": "Use this type if you want to store or send integers, and they usually have small size."
        },
        "varInt32": {
            "prefix": "varInt32",
            "body": "varInt32",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "varUint": {
            "prefix": "varUint",
            "body": "varUint",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "varUint16": {
            "prefix": "varUint16",
            "body": "varUint16",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "varUint32": {
            "prefix": "varUint32",
            "body": "varUint32",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "ExtraCurrencyCollection": {
            "prefix": "ExtraCurrencyCollection",
            "body": "ExtraCurrencyCollection",
            "description": ""
        },
        "array": {
            "prefix": "array",
            "body": "array",
            "description": ""
        },
        "vector": {
            "prefix": "vector(Type)",
            "body": "vector(${1:Type}",
            "description": ""
        },
        "string": {
            "prefix": "string",
            "body": "string",
            "description": ""
        },
        "bool": {
            "prefix": "bool",
            "body": "bool",
            "description": ""
        },
        "hash": {
            "prefix": "hash",
            "body": "hash",
            "description": ""
        },
        "bytes2": {
            "prefix": "bytes2",
            "body": "bytes2",
            "description": ""
        },
        "this": {
            "prefix": "this",
            "body": "this",
            "description": "This is the refer to enum, struct or contract"
        },
        "extMsg": {
            "prefix": ".extMsg",
            "body": "extMsg",
            "description": "Call options similar to buildExtMsg function call. Note: this type of call should be used only offchain in debot contracts.\n"
        }
    }
}