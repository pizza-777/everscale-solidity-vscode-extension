{
    ".source.ton-solidity": {
        "pragma ton-solidity": {
            "prefix": "pragma ton-solidity",
            "body": "pragma ton-solidity >= ${1:version};",
            "description": [
                "It's used to reject compilation source file with some versions of the compiler.\n",
                "Example:\n",
                "```\npragma ton-solidity >= 0.57.0; // Check compiler version is at least 0.57.0\n```",
                "```\npragma ton-solidity ^ 0.57.0; // Check compiler version is at least 0.57.0 and less 0.57.0\n```",
                "```\npragma ton-solidity \\< 0.57.0; // Check compiler version is less 0.57.0\n```\n"
            ]
        },
        "pragma ever-solidity": {
            "prefix": "pragma ever-solidity",
            "body": "pragma ever-solidity >= ${1:version};",
            "description": [
                "It's used to reject compilation source file with some versions of the compiler.\n",
                "Example:\n",
                "pragma ever-solidity >= 0.57.0; // Check compiler version is at least 0.57.0",
                "pragma ever-solidity ^ 0.57.0; // Check compiler version is at least 0.57.0 and less 0.57.0",
                "pragma ever-solidity < 0.57.0; // Check compiler version is less 0.57.0"
            ]
        },
        "ignoreIntOverflow": {
            "prefix": "ignoreIntOverflow",
            "body": "ignoreIntOverflow;",
            "description": "Turns off binary operation result overflow check."
        },
        "pragma AbiHeader": {
            "prefix": "pragmа AbiHeader",
            "body": "pragma AbiHeader ${1|time,notime,pubkey,expire|};",
            "description": [
                "Note. AbiHeader time is DEPRECATED",
                "\n - pubkey (uint256) - optional public key that the message can be signed with.\n - time (uint64) - local time when message was created. Used for replay protection.\n - expire (uint32) - time when the message should be meant as expired.\n\nNote:\n\n - time presents in external messages if pragma AbiHeader time is used OR there is no afterSignatureCheck function defined in the contract.\n - time doesn't present in external messages if pragma AbiHeader time isn't used AND there is afterSignatureCheck function defined in the contract.\nDefined headers are listed in *.abi.json file in header section.\n"
            ]
        },
        "pragma msgValue": {
            "prefix": "pragma msgValue",
            "body": "pragma msgValue ${1: value};",
            "description": [
                "```\npragma msgValue \\<value>;\n```\n",
                "Allows specifying default value in nanotons attached to the internal messages that contract sends to call another contract. If it's not specified, this value is set to 10 000 000 nanotons.\n",
                "Example:\n",
                "```\npragma msgValue 123456789;\n```",
                "```\npragma msgValue 1 ever;\n```\n"
            ]
        },
        "pragma copyleft": {
            "prefix": "pragma copyleft",
            "body": "pragma copyleft ${1:type}, ${2:walletAddress};",
            "description": [
                "It is an experimental feature available only in certain blockchain deployments.\n",
                "Parameters:\n\n<type> (uint8) - copyleft type.\n<wallet_address> (uint256) - author's wallet address in masterchain.\n",
                "If contract has the copyleft pragma, it means that after each transaction some part of validator's fee is transferred to <wallet_address> according to the <type> rule.\n",
                "For example:\n",
                "```\npragma copyleft 0, 0x2cfbdc31c9c4478b61472c72615182e9567595b857b1bba9e0c31cd9942f6ca41;\n```"
            ]
        },
        "pragma upgrade func": {
            "prefix": "pragma upgrade func",
            "body": "pragma upgrade func;",
            "description": [
                "Defines that code is compiled with special selector that is needed to upgrade func/solidity contracts.\n"                
            ]
        },
        "pragma upgrade oldsol": {
            "prefix": "pragma upgrade oldsol",
            "body": "pragma upgrade oldsol;",
            "description": [
                "Defines that code is compiled with special selector that is needed to upgrade func/solidity contracts.\n"                
            ]
        },
        "import contract": {
            "prefix": "import",
            "body": "import \"${1:contract}\";",
            "description": [
                "TON Solidity compiler allows user to import local and remote files using link starting with http. If import file name starts with http, then compiler tries to download the file using this link and saves it to the folder .solc_imports. If compiler fails to create this folder of to download the file, then an error is emitted.\n",
                "Note: to import file from GitHub, one should use link to the raw version of the file.\n",
                "Example:\n",
                "```\npragma ton-solidity >=0.57.0;\n```\n",
                "```\npragma AbiHeader expire;\n```\n",
                "```\npragma AbiHeader time;\n```\n",
                "```\npragma AbiHeader pubkey;\n```\n",
                "```\nimport \"https://github.com/tonlabs/debots/raw/9c6ca72b648fa51962224ec0d7ce91df2a0068c1/Debot.sol\";\n```",
                "```\nimport \"https://github.com/tonlabs/debots/raw/9c6ca72b648fa51962224ec0d7ce91df2a0068c1/Terminal.sol\";\n```",
                "```\ncontract HelloDebot is Debot {\n\\\\...\n}\n```"
            ]
        },
        "contract declaration": {
            "prefix": "contract",
            "body": "contract ${1:Name} {\n\t$0\n}"
        },
        "library declaration": {
            "prefix": "library",
            "body": "library ${1:Name} {\n\t$0\n}",
            "description": [
                "Libraries are similar to contracts, but they cannot have state variables and cannot inherit nor be inherited. Libraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (using qualified access like LibName.func(a, b, c)). There is also another way to call library function: obj.func(b, c).\n",
                "For now libraries are stored as a part of the code of the contact that uses libraries. In future, it can be changed."
            ]
        },
        "interface declaration": {
            "prefix": "interface",
            "body": "interface ${1:Name} {\n\t$0\n}"
        },
        "enum declaration": {
            "prefix": "enum",
            "body": "enum ${1:Name} {${2:item1}, ${3:item2} }"
        },
        "mapping declaration": {
            "prefix": "mapping",
            "body": "mapping (${1:type1}=>${2:type2}) ${3:name};"
        },
        "constructor declaration": {
            "prefix": "constructor",
            "body": "constructor(${1:type} ${2:name}) public {\n\t$0\n}"
        },
        "function declaration": {
            "prefix": "func",
            "body": "function ${1:name}(${2:type} ${3:name}) ${4|public,private,internal,external|} {\n\t$0\n}"
        },
        "function return declaration": {
            "prefix": "funcr",
            "body": "function ${1:name}(${2:type} ${3:name}) ${4|public,private,internal,external|} returns (${4:type} ${5:name}) {\n\t$0\n}"
        },
        "function view declaration": {
            "prefix": "funcrview",
            "body": "function ${1:name}(${2:type} ${3:name}) view public returns (${4:type} ${5:name}) {\n\t$0\n}"
        },
        "event declaration": {
            "prefix": "event",
            "body": "event ${1:name}(${2:type} ${3:name} $0);"
        },
        "emit declaration": {
            "prefix": "emit",
            "body": "emit ${1:event_name}(${2:var});"
        },
        "error declaration": {
            "prefix": "error",
            "body": "error ${1:name}(${2:type} ${3:name} $0);"
        },
        "modifier declaration": {
            "prefix": "modifier",
            "body": "modifier ${1:name}($2) {\n\t$0_;\n}"
        },
        "if else statement": {
            "prefix": "ife",
            "body": "if (${1:condition}) {\n\t$2\n} else {\n\t$0\n}"
        },
        "for statement": {
            "prefix": "for",
            "body": "for (uint256 ${1:index} = 0; $1 \\< ${2:array}.length; $1${3:++}) {\n\t$0\n}"
        },
        "unchecked": {
            "prefix": "unchecked",
            "body": "unchecked {\n\t$0\n}"
        },
        "natspec contract": {
            "prefix": "///nat_contract",
            "body": "/// @title A title that should describe the contract/interface\r\n/// @author The name of the author\r\n/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details",
            "description": "natspec for contract"
        },
        "natspec variable": {
            "prefix": "///nat_statevariable",
            "body": "/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details\r\n/// @return Documents the return variables of a contract’s function state variable\r\n/// @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)",
            "description": "natspec for state variable"
        },
        "natspec function": {
            "prefix": "///nat_function",
            "body": "/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details\r\n/// @param Documents a parameter just like in doxygen (must be followed by parameter name)\r\n/// @return Documents the return variables of a contract’s function state variable\r\n/// @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)",
            "description": "natspec for function"
        },
        "natspec event": {
            "prefix": "///nat_event",
            "body": "/// @notice Explain to an end user what this does\r\n/// @dev Explain to a developer any extra details\r\n/// @param Documents a parameter just like in doxygen (must be followed by parameter name)",
            "description": "natspec for event"
        },
        "<TvmCell>.depth": {
            "prefix": ".depth",
            "body": ".depth()",
            "description": [
                "```\n<TvmCell>.depth() returns(uint64);\n```\n",
                "Returns the depth of TvmCell c. If c has no references, then d = 0; otherwise d is one plus the maximum of depths of cells referred to from c. If c is a Null instead of a Cell, returns zero."
            ]
        },
        "<TvmCell>.dataSize": {
            "prefix": ".dataSize",
            "body": ".dataSize(${uint n})",
            "description": [
                "```\n<TvmCell>.dataSize(uint n) returns (uint cells, uint bits, uint refs);\n```\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. This function is a wrapper for opcode \"CDATASIZE\" "
            ]
        },
        "<TvmCell>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": ".dataSizeQ(${uint n})",
            "description": [
                "```\n<TvmCell>.dataSizeQ(uint n) returns (optional(uint cells, uint bits, uint refs));\n```\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. This function is a wrapper for opcode \"CDATASIZEQ\" "
            ]
        },
        "<TvmCell>.toSlice": {
            "prefix": ".toSlice",
            "body": ".toSlice()",
            "description": [
                "```\n<TvmCell>.toSlice() returns (TvmSlice);\n```\n",
                "Converts the cell to a slice."
            ]
        },
        "<TvmSlice>.empty": {
            "prefix": ".empty",
            "body": ".empty()",
            "description": [
                "```\n<TvmSlice>.empty() returns (bool);\n```\n",
                "Checks whether a Slice is empty (i.e., contains no bits of data and no cell references)."
            ]
        },
        "<TvmSlice>.size": {
            "prefix": ".size",
            "body": ".size()",
            "description": [
                "```\n<TvmSlice>.size() returns (uint16 bits, uint8 refs);\n```\n",
                "Returns number of data bits and references in the slice."
            ]
        },
        "<TvmSlice>.dataSize": {
            "prefix": ".dataSize",
            "body": ".dataSize(${uint n})",
            "description": [
                "```\n<TvmSlice>.dataSize(uint n) returns (uint cells, uint bits, uint refs);\n```\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. Note that the returned count of distinct cells does not take into account the cell that contains the slice itself. This function is a wrapper for opcode SDATASIZE"
            ]
        },
        "<TvmSlice>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": ".dataSizeQ(${uint n})",
            "description": [
                "```\n<TvmSlice>.dataSizeQ(uint n) returns (optional(uint cells, uint bits, uint refs));\n```\n",
                "Returns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. Note that the returned count of distinct cells does not take into account the cell that contains the slice itself. This function is a wrapper for opcode SDATASIZEQ"
            ]
        },
        "<TvmSlice>.bits": {
            "prefix": ".bits",
            "body": ".bits()",
            "description": [
                "```\n<TvmSlice>.bits() returns (uint16);\n```\n",
                "Returns number of references in the slice."
            ]
        },
        "<TvmSlice>.refs": {
            "prefix": ".refs",
            "body": ".refs()",
            "description": [
                "```\n<TvmSlice>.refs() returns (uint8);\n```\n",
                "Returns number of references in the slice."
            ]
        },
        "<TvmSlice>.bitsAndRefs": {
            "prefix": ".bitsAndRefs",
            "body": ".bitsAndRefs()",
            "description": [
                "```\n<TvmSlice>.bitsAndRefs() returns (uint16, uint8);\n```\n",
                "Returns number of data bits and references in the slice."
            ]
        },
        "<TvmSlice>.depth": {
            "prefix": ".depth",
            "body": ".depth()",
            "description": [
                "```\n<TvmSlice>.depth() returns (uint64);\n```\n",
                "Returns the depth of the slice. If slice has no references, then 0 is returned, otherwise function result is one plus the maximum of depths of the cells referred to from the slice."
            ]
        },
        "<TvmSlice>.hasNBits": {
            "prefix": ".hasNBits",
            "body": ".hasNBits(${uint10 bits}))",
            "description": [
                "```\n<TvmSlice>.hasNBits(uint10 bits) returns (bool);\n```\n",
                "Checks whether the slice contains the specified amount of data bits."
            ]
        },
        "<TvmSlice>.hasNRefs": {
            "prefix": ".hasNRefs",
            "body": ".hasNRefs(${uint2 bits}))",
            "description": [
                "```\n<TvmSlice>.hasNRefs(uint2 bits) returns (bool);\n```\n",
                "Checks whether the slice contains the specified amount of references."
            ]
        },
        "<TvmSlice>.hasNBitsAndRefs": {
            "prefix": ".hasNBitsAndRefs",
            "body": ".hasNBitsAndRefs(${uint10 bits}, ${uint2 refs})",
            "description": [
                "```\n<TvmSlice>.hasNBitsAndRefs(uint10 bits, uint2 refs) returns (bool);\n```\n",
                "Checks whether the slice contains the specified amount of data bits and references."
            ]
        },
        "<TvmSlice>.compare": {
            "prefix": ".compare",
            "body": ".compare(${1:TvmSlice other})",
            "description": [
                "```\n<TvmSlice>.compare(TvmSlice other) returns (int2);\n```\n",
                "Lexicographically compares the slice and other data bits of the root slice and returns result as an integer:\n",
                " * 1 - slice > other",
                " * 0 - slice == other",
                " * -1 - slice < other"
            ]
        },
        "<TvmSlice>.loadRef": {
            "prefix": ".loadRef",
            "body": ".loadRef()",
            "description": [
                "```\n<TvmSlice>.loadRef() returns (TvmCell);\n```\n",
                "Loads a cell from the slice reference."
            ]
        },
        "<TvmSlice>.loadRefAsSlice": {
            "prefix": ".loadRefAsSlice",
            "body": ".loadRefAsSlice()",
            "description": [
                "```\n<TvmSlice>.loadRefAsSlice() returns (TvmSlice);\n```\n",
                "Loads a cell from the slice reference and converts it into a slice."
            ]
        },
        "<TvmSlice>.loadSigned": {
            "prefix": ".loadSigned",
            "body": ".loadSigned(${1:uint16 bitSize})",
            "description": [
                "```\n<TvmSlice>.loadSigned(uint16 bitSize) returns (int);\n```\n",
                "Loads a signed integer with the given bitSize from the slice."
            ]
        },
        "<TvmSlice>.loadInt": {
            "prefix": ".loadInt",
            "body": "loadInt(${1:int9 bitSize})",
            "description": [
                "```\n<TvmSlice>.loadInt(int9 bitSize) returns (int);\n```\n",
                "Loads a signed integer with the given **bitSize** from the `TvmSlice`."
            ]
        },
        "<TvmSlice>.loadIntQ": {
            "prefix": ".loadIntQ",
            "body": "loadIntQ(${1:int9 bitSize})",
            "description": [
                "```\n<TvmSlice>.loadIntQ(int9 bitSize) returns (optional(int));\n```\n",
                "Loads a signed integer with the given **bitSize** from the `TvmSlice` if `TvmSlice` contains it. Otherwise, returns `null`"
            ]
        },
        "<TvmSlice>.loadUint": {
            "prefix": ".loadUint",
            "body": "loadUint(${1:uint9 bitSize})",
            "description": [
                "```\n<TvmSlice>.loadUint(uint9 bitSize) returns (uint);\n```\n",
                "Loads an unsigned integer with the given **bitSize** from the `TvmSlice`."
            ]
        },
        "<TvmSlice>.loadUintQ": {
            "prefix": ".loadUintQ",
            "body": "loadUintQ(${1:uint9 bitSize})",
            "description": [
                "```\n<TvmSlice>.loadUintQ(uint9 bitSize) returns (optional(uint));\n```\n",
                "Loads an unsigned integer with the given **bitSize** from the `TvmSlice` if `TvmSlice` contains it. Otherwise, returns `null`"
            ]
        },
        "<TvmSlice>.loadUnsigned": {
            "prefix": ".loadSiloadUnsignedgned",
            "body": ".loadUnsigned(${1:uint16 bitSize})",
            "description": [
                "```\n<TvmSlice>.loadSigned(uint16 bitSize) returns (uint);\n```\n",
                "Loads an unsigned integer with the given bitSize from the slice."
            ]
        },
        "<TvmSlice>.loadTons": {
            "prefix": ".loadTons",
            "body": ".loadTons()",
            "description": [
                "```\n<TvmSlice>.loadTons() returns (uint128);\n```\n",
                "Loads (deserializes) VarUInteger 16 and returns an unsigned 128-bit integer."
            ]
        },
        "<TvmSlice>.loadIntLE2": {
            "prefix": ".loadIntLE2",
            "body": ".loadIntLE2()",
            "description": [
                "```\n<TvmSlice>.loadIntLE2() returns (int16);\n```\n",
                "Loads the little-endian integer from TvmSlice.\n"
            ]
        },
        "<TvmSlice>.loadIntLE4": {
            "prefix": ".loadIntLE4",
            "body": ".loadIntLE4()",
            "description": [
                "```\n<TvmSlice>.loadIntLE4() returns (int32);\n```\n",
                "Loads the little-endian integer from TvmSlice.\n"
            ]
        },
        "<TvmSlice>.loadIntLE8": {
            "prefix": ".loadIntLE8",
            "body": ".loadIntLE8()",
            "description": [
                "```\n<TvmSlice>.loadIntLE8() returns (int64);\n```\n",
                "Loads the little-endian integer from TvmSlice.\n"
            ]
        },
        "<TvmSlice>.loadIntLE4Q": {
            "prefix": ".loadIntLE4Q",
            "body": "loadIntLE4Q()",
            "description": [
                "```\n<TvmSlice>.loadIntLE4Q() returns (optional(int32));\n```\n",
                "Loads the little-endian integer from TvmSlice. Returns null if it's impossible to load the integer.\n"
            ]
        },
        "<TvmSlice>.loadIntLE8Q": {
            "prefix": ".loadIntLE8Q",
            "body": "loadIntLE8Q()",
            "description": [
                "```\n<TvmSlice>.loadIntLE8Q() returns (optional(int64));\n```\n",
                "Loads the little-endian integer from TvmSlice. Returns null if it's impossible to load the integer.\n"
            ]
        },        
        "<TvmSlice>.preloadIntLE4()": {
            "prefix": ".preloadIntLE4",
            "body": "preloadIntLE4()",
            "description": [
                "```\n<TvmSlice>.preloadIntLE4() returns (int32);\n```\n",
                "Loads the little-endian integer from TvmSlice, but doesn't modify TvmSlice.\n"
            ]
        },
        "<TvmSlice>.preloadIntLE4Q()": {
            "prefix": ".preloadIntLE4Q",
            "body": "preloadIntLE4Q()",
            "description": [
                "```\n<TvmSlice>.preloadIntLE4Q() returns (optional(int32));\n```\n",
                "Loads the little-endian integer from TvmSlice, but doesn't modify TvmSlice. Returns null if it's impossible to load the integer.\n"
            ]
        },
        "<TvmSlice>.preloadIntLE8()": {
            "prefix": ".preloadIntLE8",
            "body": "preloadIntLE8()",
            "description": [
                "```\n<TvmSlice>.preloadIntLE8() returns (int64);\n```\n",
                "Loads the little-endian integer from TvmSlice, but doesn't modify TvmSlice.\n"
            ]
        },
        "<TvmSlice>.preloadIntLE8Q()": {
            "prefix": ".preloadIntLE8Q",
            "body": "preloadIntLE8Q()",
            "description": [
                "```\n<TvmSlice>.preloadIntLE8Q() returns (optional(int64));\n```\n",
                "Loads the little-endian integer from TvmSlice, but doesn't modify TvmSlice. Returns null if it's impossible to load the integer.\n"
            ]
        },
        "<TvmSlice>.preloadUintLE4()":{
            "prefix": ".preloadUintLE4",
            "body": "preloadUintLE4()",
            "description": [
                "```\n<TvmSlice>.preloadUintLE4() returns (uint32);\n```\n",
                "Loads the little-endian unsigned integer from TvmSlice, but doesn't modify TvmSlice.\n"
            ]
        },
        "<TvmSlice>.preloadUintLE4Q()":{
            "prefix": ".preloadUintLE4Q",
            "body": "preloadUintLE4Q()",
            "description": [
                "```\n<TvmSlice>.preloadUintLE4Q() returns (optional(uint32));\n```\n",
                "Loads the little-endian unsigned integer from TvmSlice, but doesn't modify TvmSlice. Returns null if it's impossible to load the integer.\n"
            ]
        },
        "<TvmSlice>.preloadUintLE8()":{
            "prefix": ".preloadUintLE8",
            "body": "preloadUintLE8()",
            "description": [
                "```\n<TvmSlice>.preloadUintLE8() returns (uint64);\n```\n",
                "Loads the little-endian unsigned integer from TvmSlice, but doesn't modify TvmSlice.\n"
            ]
        },
        "<TvmSlice>.preloadUintLE8Q()":{
            "prefix": ".preloadUintLE8Q",
            "body": "preloadUintLE8Q()",
            "description": [
                "```\n<TvmSlice>.preloadUintLE8Q() returns (optional(uint64));\n```\n",
                "Loads the little-endian unsigned integer from TvmSlice, but doesn't modify TvmSlice. Returns null if it's impossible to load the integer.\n"
            ]
        },
        "<TvmSlice>.loadSlice": {
            "prefix": ".loadSlice",
            "body": ".loadSlice(${1:uint10 bits})",
            "description": [
                "```\n<TvmSlice>.loadSlice(uint10 bits) returns (TvmSlice);\n```\n",
                "```\n<TvmSlice>.loadSlice(uint10 bits), uint refs) returns (TvmSlice);\n```\n",
                "Loads the first bits and refs references from the TvmSlice"
            ]
        },
        "<TvmSlice>.loadSliceQ": {
            "prefix": ".loadSliceQ",
            "body": "loadSliceQ(${1:uint10 bits})",
            "description": [
                "```\n<TvmSlice>.loadSliceQ(uint10 bits) returns (optional(TvmSlice));\n```\n",
                "```\n<TvmSlice>.loadSliceQ(uint10 bits, uint2 refs) returns (optional(TvmSlice));\n```\n",
                "Loads the first `bits` bits and `refs` references from `TvmSlice`"
            ]
        },
        "<TvmSlice>.decodeFunctionParams": {
            "prefix": ".decodeFunctionParams",
            "body": ".decodeFunctionParams(${1:functionName})",
            "description": [
                "Decodes parameters of the function or constructor (if contract type is provided). This function is usually used in onBounce function.\n",
                "Example:\n",
                "Decode parameters of the public/external function without \"responsible\" attribute:\n",
                "```\n<TvmSlice>.decodeFunctionParams(functionName) returns (TypeA a, TypeB b, ...);\n```\n",
                "Decode parameters of the public function which returns values:\n",
                "```\n<TvmSlice>.decodeFunctionParams(functionName) returns (uint32 callbackFunctionId, TypeA a, TypeB b, ...);\n```\n",
                "Decode constructor parameters:\n",
                "```\n<TvmSlice>.decodeFunctionParams(ContractName) returns (TypeA a, TypeB b, ...);\n```\n"
            ]
        },
        "<TvmSlice>.loadFunctionParams": {
            "prefix": ".loadFunctionParams",
            "body": "loadFunctionParams(${1:functionName})",
            "description": [
                "Loads parameters of the function or constructor (if contract type is provided). This function is usually used in onBounce function.\n",
                "Example:\n",
                "Load parameters of the public/external function without \"responsible\" attribute:\n",
                "```\n<TvmSlice>.loadFunctionParams(functionName) returns (TypeA a, TypeB b, ...);\n```\n",
                "Loads parameters of the public function which returns values:\n",
                "```\n<TvmSlice>.loadFunctionParams(functionName) returns (uint32 callbackFunctionId, TypeA a, TypeB b, ...);\n```\n",
                "Loads constructor parameters:\n",
                "```\n<TvmSlice>.loadFunctionParams(ContractName) returns (TypeA a, TypeB b, ...);\n```\n"
            ]
        },     
        "<TvmSlice>.loadStateVars()": {
            "prefix": ".loadStateVars",
            "body": "loadStateVars(${1:ContractName})",
            "description": [
                "```\n<TvmSlice>.loadStateVars(ContractName) returns (uint256 /*pubkey*/, uint64 /*timestamp*/, bool /*constructorFlag*/, Type1 /*var1*/, Type2 /*var2*/, ...);\n```\n",
                "Loads state variables from slice that is obtained from the field data of stateInit\n"                
            ]
        },
        "<TvmSlice>.decodeStateVars()": {
            "prefix": ".decodeStateVars",
            "body": "decodeStateVars(${1:ContractName})",
            "description": [
                "DEPRECATED\n",
                "```\n<TvmSlice>.decodeStateVars(ContractName) returns (uint256 /*pubkey*/, uint64 /*timestamp*/, bool /*constructorFlag*/, Type1 /*var1*/, Type2 /*var2*/, ...);\n```\n",
                "Decode state variables from slice that is obtained from the field data of stateInit\n"                
            ]
        },
        "<TvmSlice>.skip": {
            "prefix": ".skip",
            "body": ".skip(${1:uint10 bits}${0: ,uint2 refs})",
            "description": [
                "```\n<TvmSlice>.skip(uint10 bits);\n```\n",
                "```\n<TvmSlice>.skip(uint10 bits, uint2 refs);\n```\n",
                "Skips the first bits and refs references from the TvmSlice."
            ]
        },
        "<TvmSlice>.loadZeroes": {
            "prefix": ".loadZeroes",
            "body": "loadZeroes()",
            "description": [
                "```\n<TvmSlice>.loadZeroes() returns (uint10 n);\n```\n",
                " Returns the count n of leading zero bits in TvmSlice, and removes these bits from TvmSlice."
            ]
        },
        "<TvmSlice.loadOnes": {
            "prefix": ".loadOnes",
            "body": "loadOnes()",
            "description": [
                "```\n<TvmSlice>.loadOnes() returns (uint10 n);\n```\n",
                "Returns the count n of leading one bits in TvmSlice, and removes these bits from TvmSlice."
            ]
        },
        "<TvmSlice>.loadSame": {
            "prefix": ".loadSame",
            "body": "loadSame()",
            "description": [
                "```\n<TvmSlice>.loadSame() returns (uint10 n);\n```\n",
                "Returns the count n of leading bits equal to 0 ≤ value ≤ 1 in TvmSlice, and removes these bits from TvmSlice."
            ]
        },
        "<TvmSlice>.preload": {
            "prefix": ".preload",
            "body": "preload()",
            "description": [
                "```\n<TvmSlice>.preload(TypeA, TypeB, ...) returns (TypeA /*a*/, TypeB /*b*/, ...);\n```\n",
                "Same as <TvmSlice>.load() but doesn't modify TvmSlice."
            ]
        },
        "<TvmSlice>.preloadQ": {
            "prefix": ".preloadQ",
            "body": "preloadQ()",
            "description": [
                "```\n<TvmSlice>.preloadQ(TypeA, TypeB, ...) returns (optional(TypeA, TypeB, ...));\n```\n",
                "Same as <TvmSlice>.loadQ() but doesn't modify TvmSlice."
            ]
        },
        "<TvmSlice>.preloadRef": {
            "prefix": ".preloadRef",
            "body": "preloadRef()",
            "description": [
                "Returns the first cell reference of TvmSlice.\n",
                "```\n<TvmSlice>.preloadRef() returns (TvmCell);\n```\n",          
                "Returns the index cell reference of TvmSlice, where 0 ≤ index ≤ 3.\n",      
                "```\n<TvmSlice>.preloadRef(uint2 index) returns (TvmCell);\n```\n"                
            ]
        },
        "<TvmSlice>.preloadInt": {
            "prefix": ".preloadInt",
            "body": "preloadInt(${1:uint9 bitSize})",
            "description": [
                "Same as <TvmSlice>.loadInt() but doesn't modify TvmSlice.\n",
                "```\n<TvmSlice>.preloadInt(uint9 bitSize) returns (int);\n```\n"
            ]
        },
        "<TvmSlice>.preloadIntQ": {
            "prefix": ".preloadIntQ",
            "body": "preloadIntQ(${1:uint9 bitSize})",
            "description": [
                "Same as <TvmSlice>.loadIntQ() but doesn't modify TvmSlice.\n",
                "```\n<TvmSlice>.preloadIntQ(uint9 bitSize) returns (optional(int));\n```\n"
            ]
        },
        "<TvmSlice>.preloadUint": {
            "prefix": ".preloadUint",
            "body": "preloadUint(${1:uint9 bitSize})",
            "description": [
                "Same as <TvmSlice>.loadUint() but doesn't modify TvmSlice.\n",
                "```\n<TvmSlice>.preloadUint(uint9 bitSize) returns (uint);\n```\n"
            ]
        },
        "<TvmSlice>.preloadUintQ": {
            "prefix": ".preloadUintQ",
            "body": "preloadUintQ(${1:uint9 bitSize})",
            "description": [
                "Same as <TvmSlice>.loadUintQ() but doesn't modify TvmSlice.\n",
                "```\n<TvmSlice>.preloadUintQ(uint9 bitSize) returns (optional(uint));\n```\n"
            ]
        },
        "<TvmSlice>.preloadSlice": {
            "prefix": ".preloadSlice",
            "body": "preloadSlice(${1:uint10 bits})",
            "description": [
                "Same as <TvmSlice>.loadSlice() but doesn't modify TvmSlice.\n",
                "```\n<TvmSlice>.preloadSlice(uint10 bits) returns (TvmSlice);\n```\n",
                "```\n<TvmSlice>.preloadSlice(uint10 bits, uint refs) returns (TvmSlice);\n```\n"
            ]
        },
        "<TvmSlice>.preloadSliceQ": {
            "prefix": ".preloadSliceQ",
            "body": "preloadSliceQ(${1:uint10 bits})",
            "description": [
                "Same as <TvmSlice>.loadSliceQ() but doesn't modify TvmSlice.\n",
                "```\n<TvmSlice>.preloadSliceQ(uint10 bits) returns (optional(TvmSlice));\n```\n",
                "```\n<TvmSlice>.preloadSliceQ(uint10 bits, uint4 refs) returns (optional(TvmSlice));\n```\n"
            ]
        },
        "<TvmBuilder>.toSlice": {
            "prefix": ".toSlice",
            "body": ".toSlice()",
            "description": [
                "```\n<TvmBuilder>.toSlice() returns (TvmSlice);\n```\n",
                "Converts the builder into a slice."
            ]
        },
        "<TvmBuilder>.toCell": {
            "prefix": ".toCell",
            "body": ".toCell()",
            "description": [
                "```\n<TvmBuilder>.toCell() returns (TvmCell);\n```\n",
                "Converts the builder into a cell."
            ]
        },
        "<TvmBuilder>.bits": {
            "prefix": ".bits",
            "body": ".bits()",
            "description": [
                "```\n<TvmBuilder>.bits() returns (uint16);\n```\n",
                "Returns the number of data bits already stored in the builder."
            ]
        },
        "<TvmBuilder>.refs": {
            "prefix": ".refs",
            "body": ".refs()",
            "description": [
                "```\n<TvmBuilder>.refs() returns (uint8);\n```\n",
                "Returns the number of references already stored in the builder."
            ]
        },
        "<TvmBuilder>.bitsAndRefs": {
            "prefix": ".bitsAndRefs",
            "body": ".bitsAndRefs()",
            "description": [
                "```\n<TvmBuilder>.bitsAndRefs() returns (uint16 bits, uint8 refs);\n```\n",
                "Returns the number of data bits and references already stored in the builder."
            ]
        },
        "<TvmBuilder>.remBits": {
            "prefix": ".remBits",
            "body": ".remBits()",
            "description": [
                "```\n<TvmBuilder>.remBits() returns (uint16);\n```\n",
                "Returns the number of data bits that can still be stored in the builder."
            ]
        },
        "<TvmBuilder>.remRefs": {
            "prefix": ".remRefs",
            "body": ".remRefs()",
            "description": [
                "```\n<TvmBuilder>.remRefs() returns (uint8);\n```\n",
                "Returns the number of references that can still be stored in the builder."
            ]
        },
        "<TvmBuilder>.remBitsAndRefs": {
            "prefix": ".remBitsAndRefs",
            "body": ".remBitsAndRefs()",
            "description": [
                "```\n<TvmBuilder>.remBitsAndRefs() returns (uint16 bits, uint8 refs);\n```\n",
                "Returns the number of data bits and references that can still be stored in the builder."
            ]
        },
        "<TvmBuilder>.depth": {
            "prefix": ".depth",
            "body": ".depth()",
            "description": [
                "```\n<TvmBuilder>.depth() returns (uint64);\n```\n",
                "Returns the depth of the builder. If no cell references are stored in the builder, then 0 is returned; otherwise function result is one plus the maximum of depths of cells referred to from the builder."
            ]
        },
        "<TvmBuilder>.store": {
            "prefix": ".store",
            "body": ".store(${list_of_values})",
            "description": [
                "```\n<TvmBuilder>.store(list_of_values);\n```\n",
                "Stores the list of values in the builder.\n",
                "Example:\n",
                "```\nuint8 a = 11;\n```\n",
                "```\nint16 b = 22;\n```\n",
                "```\nTvmBuilder builder;\n```\n",
                "```\nbuilder.store(a, b, uint(33));\n```\n"
            ]
        },
        "<TvmBuilder>.storeOnes": {
            "prefix": ".storeOnes",
            "body": ".storeOnes(${1:uint10 n})",
            "description": [
                "```\n<TvmBuilder>.storeOnes(uint10 n);\n```\n",
                "Stores n binary ones into the Builder."
            ]
        },
        "<TvmBuilder>.storeZeroes": {
            "prefix": ".storeZeroes",
            "body": ".storeZeroes(${1:uint10 n})",
            "description": [
                "```\n<TvmBuilder>.storeZeroes(uint10 n);\n```\n",
                "Stores n binary zeroes into the Builder."
            ]
        },
        "<TvmBuilder>.storeSame": {
            "prefix": ".storeSame",
            "body": "storeSame(${1:uint10 n, uint1 value})",
            "description": [
                "<TvmBuilder>.storeSame(uint10 n, uint1 value);\n",
                "Stores n binary values (0 ≤ value ≤ 1) into the TvmBuilder."
            ]
        },
        "<TvmBuilder>.storeInt": {
            "prefix": ".storeInt",
            "body": "storeInt(${1:int256 value}, ${2:uint9 bitSize})",
            "description": [
                "```\n<TvmBuilder>.storeInt(int256 value, uint9 bitSize);\n```\n",
                "Stores a signed integer value with given bitSize in the TvmBuilder."
            ]
        },
        "<TvmBuilder>.storeSigned": {
            "prefix": ".storeSigned",
            "body": "storeSigned(${1:int256 value}, ${2:uint16 bitSize})",
            "description": [
                "```\n<TvmBuilder>.storeSigned(int256 value, uint16 bitSize);\n```\n",
                "Stores a signed integer value with given bitSize in the builder."
            ]
        },
        "<TvmBuilder>.storeUnsigned": {
            "prefix": ".storeUnsigned",
            "body": "storeUnsigned(${1:uint256 value}, ${2:uint16 bitSize})",
            "description": [
                "```\n<TvmBuilder>.storeUnsigned(uint256 value, uint16 bitSize);\n```\n",
                "Stores an unsigned integer value with given bitSize in the builder."
            ]
        },
        "<TvmBuilder>.storeUint": {
            "prefix": ".storeUint",
            "body": "storeUint(${1:uint256 value}, ${2:uint9 bitSize})",
            "description": [
                "```\n<TvmBuilder>.storeUint(uint256 value, uint9 bitSize);\n```\n",
                "Stores an unsigned integer value with given bitSize in the TvmBuilder."
            ]
        },
        "<TvmBuilder>.storeIntLE2": {
            "prefix": ".storeIntLE2",
            "body": "storeIntLE2(${1:int16 value})",
            "description": [
                "```\n<TvmBuilder>.storeIntLE2(int16 value);\n```\n",
                "Stores the little-endian integer."
            ]
        },
        "<TvmBuilder>.storeIntLE4": {
            "prefix": ".storeIntLE4",
            "body": "storeIntLE4(${1:int32 value})",
            "description": [
                "```\n<TvmBuilder>.storeIntLE4(int32 value);\n```\n",
                "Stores the little-endian integer."
            ]
        },
        "<TvmBuilder>.storeIntLE8": {
            "prefix": ".storeIntLE8",
            "body": "storeIntLE8(${1:int64 value})",
            "description": [
                "```\n<TvmBuilder>.storeIntLE8(int64 value);\n```\n",
                "Stores the little-endian integer."
            ]
        },
        "<TvmBuilder>.storeUintLE2(uint16)":
        {
            "prefix": ".storeUintLE2",
            "body": "storeUintLE2(${1:uint16 value})",
            "description": [
                "```\n<TvmBuilder>.storeUintLE2(uint16 value);\n```\n",
                "Stores the little-endian unsigned integer."
            ]
        },
        "<TvmBuilder>.storeUintLE4": {
            "prefix": ".storeUintLE4",
            "body": "storeUintLE4(${1:uint32 value})",
            "description": [
                "```\n<TvmBuilder>.storeUintLE4(uint32 value);\n```\n",
                "Stores the little-endian unsigned integer."
            ]
        },
        "<TvmBuilder>.storeUintLE8": {
            "prefix": ".storeUintLE8",
            "body": "storeUintLE8(${1:uint64 value})",
            "description": [
                "```\n<TvmBuilder>.storeUintLE8(uint64 value);\n```\n",
                "Stores the little-endian unsigned integer."
            ]
        },
        "<TvmBuilder>.storeRef": {
            "prefix": ".storeRef",
            "body": ".storeRef(${1|TvmBuilder b,TvmCell c,TvmSlice s|})",
            "description": [
                "```\n<TvmBuilder>.storeRef(TvmBuilder b);\n```\n",
                "```\n<TvmBuilder>.storeRef(TvmCell c);\n```\n",
                "```\n<TvmBuilder>.storeRef(TvmSlice s);\n```\n",
                "Stores TvmBuilder b/TvmCell c/TvmSlice c in the reference of the builder."
            ]
        },
        "<TvmBuilder>.storeTons": {
            "prefix": ".storeTons",
            "body": ".storeTons(${1:uint128 value})",
            "description": [
                "```\n<TvmBuilder>.storeTons(uint128 value);\n```\n",
                "Stores (serializes) an integer value and stores it in the builder as VarUInteger 16. See TL-B scheme."
            ]
        },
        "<optional(Type)>.get": {
            "prefix": ".get",
            "body": ".get()",
            "description": [
                "```\n<optional(Type)>.get() returns (Type);\n```\n",
                "Returns the contained value, if the optional contains one. Otherwise, throws an exception."
            ]
        },
        "<optional(T)>.getOr()": {
            "prefix": ".getOr",
            "body": "getOr(T default)",
            "description": [
                "```\n<optional(Type)>.getOr(${1:T default}) returns (T);\n```\n",
                "Returns the contained value, if the optional contains one. Otherwise, returns default."
            ]
        },
        "<optional(T)>.getOrDefault()": {
            "prefix": ".getOrDefault",
            "body": "getOrDefault()",
            "description": [
                "```\n<optional(T)>.getOrDefault() returns (T);\n```\n",
                "Returns the contained value, if the optional contains one. Otherwise, returns the default value for T type."
            ]
        },
        "optional": {
            "prefix": "optional",
            "body": "optional${(1:type) 2:name}",
            "description": [
                "```\n<optional(Type)>.get() returns (Type);\n```\n",
                "Returns the contained value, if the optional contains one. Otherwise, throws an exception."
            ]
        },
        "<optional(Type)>.hasValue": {
            "prefix": ".hasValue",
            "body": ".hasValue()",
            "description": [
                "```\n<optional(Type)>.hasValue() returns (bool);\n```\n",
                "Checks whether opt contains a value."
            ]
        },
        "<vector(Type)>.push": {
            "prefix": ".push",
            "body": ".push(${1:Type obj})",
            "description": [
                "```\n<vector(Type)>.push(Type obj);\n```\n",
                "Appends obj to the vector.\n",
                "Example:\n",
                "```\nvector(uint) vect;\n```\n",
                "```\nuint a = 11;\n```\n",
                "```\nvect.push(a);\n```\n",
                "```\nvect.push(111);\n```\n"
            ]
        },
        "<vector(Type)>.pop": {
            "prefix": ".pop",
            "body": ".pop()",
            "description": [
                "```\n<vector(Type)>.pop() returns (Type);\n```\n",
                "Pops the last value from the vector and returns is.\n",
                "Example:\n",
                "```\nvector(uint) vect;\n```\n",
                "...\n",
                "```\nuint a = vect.pop();\n```\n"
            ]
        },
        "<vector(Type)>.length": {
            "prefix": ".length",
            "body": ".length()",
            "description": [
                "```\n<vector(Type)>.length() returns (uint8);\n```\n",
                "Returns length of the vector.\n",
                "Example:\n",
                "```\nvector(uint) vect;\n```\n",
                "...\n",
                "```\nuint8 len = vect.length();\n```\n"
            ]
        },
        "<vector(Type)>.empty": {
            "prefix": ".empty",
            "body": ".empty()",
            "description": [
                "```\n<vector(Type)>.empty() returns (bool);\n```\n",
                "Checks whether the vector is empty.\n",
                "Example:\n",
                "```\nvector(uint) vect;\n```\n",
                "...\n",
                "```\nbool is_empty = vect.empty();\n```\n"
            ]
        },
        "for range": {
            "prefix": "for_range",
            "body": "for ((uint ${1:key}, uint ${2:value}) : ${3:range_expression}) {\n\t$0\n}",
            "description": [
                "Executes a for loop over a range.\n",
                "Example:\n",
                "```\nfor (uint val : arr) {}// iteration over array \n```",
                "```\nfor ((uint32 key, uint value) : map) {} // iteration over mapping \n```",
                "```\nfor ((, uint value) : map) {} // key is omitted  \n```\n"
            ]
        },
        "repeat": {
            "prefix": "repeat",
            "body": "repeat(${1:uint n}) {\n\t$0\n}",
            "description": "Allows repeating block of code several times. A repeat loop evaluates the expression only one time. This expression must have an unsigned integer type."
        },
        "bitSize": {
            "prefix": "bitSize",
            "body": "bitSize(${1:int x})",
            "description": [
                "bitSize(int x) returns (uint16)",
                "bitSize computes the smallest c ≥ 0 such that x fits into a c-bit signed integer (−2c−1 ≤ x < 2c−1).\n",
                "Example:\n",
                "require(bitSize(12) == 5); // 12 == 1100(in bin sys)",
                "```\nrequire(bitSize(1) == 2);\n```\n",
                "```\nrequire(bitSize(-1) == 1);\n```\n",
                "```\nrequire(bitSize(0) == 0);\n```\n"
            ]
        },
        "uBitSize": {
            "prefix": "uBitSize",
            "body": "uBitSize(${1:uint x})",
            "description": [
                "uBitSize(int x) returns (uint16)",
                "uBitSize computes the smallest c ≥ 0 such that x fits into a c-bit unsigned integer (0 ≤ x < 2c).\n",
                "Example:\n",
                "```\nrequire(uBitSize(10) == 4);\n```\n",
                "```\nrequire(uBitSize(1) == 1);\n```\n",
                "```\nrequire(uBitSize(0) == 0);\n```\n"
            ]
        },
        "<struct>.unpack": {
            "prefix": ".unpack",
            "body": ".unpack()",
            "description": [
                "```\n<struct>.unpack() returns (TypeA a, TypeB b\\, ...);\n```\n",
                "Unpacks all members stored in the struct.\n",
                "Example:\n",
                "```\nstruct MyStruct {\n\tuint a;\n\tint b;\n\taddress c;\n}\n```",
                "```\nfunction f() pure public {\n\tMyStruct s = MyStruct(1, -1, address(2));\n\t(uint a, int b, address c) = s.unpack();\n}\n```"
            ]
        },
        "<array>.empty": {
            "prefix": ".empty",
            "body": ".empty()",
            "description": [
                "```\n<array>.empty() returns (bool);\n```\n",
                "Returns status flag whether the array is empty (its length is 0).\n",
                "Example:\n",
                "```\nuint[] arr;\n\nrequire(arr.empty());\n\narr.push();\n\nrequire(!arr.empty());\n```\n"
            ]
        },
        "<bytes>.empty": {
            "prefix": ".empty",
            "body": ".empty()",
            "description": [
                "```\n<bytes>.empty() returns (bool);\n```\n",
                "Returns status flag whether the bytes is empty (its length is 0)."
            ]
        },
        "<bytes>.length": {
            "prefix": ".length",
            "body": ".length",
            "description": [
                "```\n<bytes>.length returns (uint)\n```\n",
                "Returns length of the byte array."
            ]
        },
        "<bytes>.toSlice": {
            "prefix": ".toSlice",
            "body": ".toSlice()",
            "description": [
                "```\n<bytes>.toSlice() returns (TvmSlice);\n```\n",
                "Converts bytes to TvmSlice.\n",
                "Warning: if length of the array is greater than 127\nthen extra bytes are stored in the first reference of the slice. Use \\<TvmSlice\\>.loadRef() to load that extra bytes."
            ]
        },
        "<bytes>.dataSize": {
            "prefix": ".dataSize",
            "body": ".dataSize(${1:uint n})",
            "description": [
                "```\n<bytes>.dataSize(uint n) returns (uint cells, uint bits, uint refs);\n```\n"
            ]
        },
        "<bytes>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": ".dataSizeQ(${1:uint n})",
            "description": [
                "```\n<bytes>.dataSizeQ(uint n) returns (optional(uint cells, uint bits, uint refs));\n```\n"
            ]
        },
        "<bytes>.append": {
            "prefix": ".append",
            "body": ".append(${1:bytes tail})",
            "description": [
                "```\n<bytes>.append(bytes tail);\n```\n",
                "Modifies the bytes by concatenating tail bytes to the end of the bytes."
            ]
        },
        "<string>.empty": {
            "prefix": ".empty",
            "body": ".empty()",
            "description": [
                "```\n<string>.empty() returns (bool);\n```\n",
                "Returns status flag whether the string is empty (its length is 0)."
            ]
        },
        "<string>.byteLength": {
            "prefix": ".byteLength",
            "body": ".byteLength()",
            "description": [
                "```\n<string>.byteLength() returns (uint32);\n```\n",
                "Returns byte length of the string data."
            ]
        },
        "<string>.substr": {
            "prefix": ".substr",
            "body": "substr(${1:uint from, uint count})",
            "description": [
                "```\n<string>.substr(uint from[, uint count]) returns (string);\n```\n",
                "Returns a substring starting from the\nbyte with number from with byte length count. Note: if count is not set, then the new string will be cut from the from byte to the end of the string.\n",
                "Example:\n",
                "```\nstring long = \"0123456789\";\nstring a = long.substr(1, 2); // a = \"12\"\nstring b = long.substr(6); // b = \"6789\"\n```"
            ]
        },
        "<string>.append": {
            "prefix": ".append",
            "body": ".append(${1:string tail})",
            "description": [
                "```\n<string>.append(string tail);\n```\n",
                "Appends the tail string to the string."
            ]
        },
        "<string>.find": {
            "prefix": ".find",
            "body": ".find(${1|substring,byte('symbol')|})",
            "description": [
                "```\n<string>.find(bytes1 symbol) returns (optional(uint32));\n```\n",
                "```\n<string>.find(string substr) returns (optional(uint32));\n```\n",
                "Looks for symbol (or substring) in the string and returns index of the first (find) occurrence. If there is no such symbol in the string, empty optional is returned."
            ]
        },
        "<string>.findLast": {
            "prefix": ".findLast",
            "body": ".findLast(${1|substring,byte('symbol')|})",
            "description": [
                "```\n<string>.findLast(bytes1 symbol) returns (optional(uint32));\n```\n",
                "```\n<string>.findLast(string substr) returns (optional(uint32));\n```\n",
                "Looks for symbol (or substring) in the string and returns index of the last (findLast) occurrence. If there is no such symbol in the string, empty optional is returned."
            ]
        },
        "<string>.toSlice": {
            "prefix": ".toSlice",
            "body": "toSlice()",
            "description": [
                "```\n<string>.toSlice() returns (TvmSlice);\n```\n",
                "Converts string to TvmSlice."                
            ]
        },
        "<string>.dataSize": {
            "prefix": ".dataSize",
            "body": "dataSize(${1:uint n})",
            "description": [
                "```\n<string>.dataSize(uint n) returns (uint /*cells*/, uint /*bits*/, uint /*refs*/);\n```\n",
                "Same as <TvmCell>.dataSize(uint n)\nReturns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then a cell overflow exception (8) is thrown. This function is a wrapper for opcode \"CDATASIZE\" "                
            ]
        },
        "<string>.dataSizeQ": {
            "prefix": ".dataSizeQ",
            "body": "dataSizeQ(${1:uint n})",
            "description": [
                "```\n<string>.dataSizeQ(uint n) returns (optional(uint /*cells*/, uint /*bits*/, uint /*refs*/));\n```\n",
                "Same as <TvmCell>.dataSizeQ(uint n)\nReturns the count of distinct cells, data bits in the distinct cells and cell references in the distinct cells. If count of the distinct cells exceeds n+1 then this function returns an optional that has no value. This function is a wrapper for opcode \"CDATASIZEQ\" "                
            ]
        },
        "format": {
            "prefix": "format",
            "body": "format(${1: string template}, ${2:TypeA a, TypeB b, ...})",
            "description": [
                "```\nformat(string template, TypeA a, TypeB b, ...) returns (string);\n```\n",
                "Builds a string with arbitrary parameters.\n",
                "Example:\n",
                "```\nformat(\"Hello {}\", 123) \\\\ \"Hello 123\"\n```\n"
            ]
        },
        "stoi": {
            "prefix": "stoi",
            "body": "stoi(${1:string inputStr})",
            "description": [
                "stoi(string inputStr) returns (optional(int) result);\n",
                "\nConverts a string into an integer. If string starts with '0x' it will be converted from a hexadecimal format, otherwise it is meant to be number in decimal format. Function returns the optional value containing integer, which can be empty in case of illegal characters in the string.\n\nWarning: this function consumes too much gas, that's why it's better not to use it onchain. Example:\n\noptional(int) res;\n\nres = stoi(\"123\"); // res ==123\n\nstring hexstr = \"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF123456789ABCDE\";\n\nres = stoi(hexstr); // res == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF123456789ABCDE\n\nres = stoi(\"0xag\"); // res == null\n"
            ]
        },
        "address": {
            "prefix": "address",
            "body": "address(${1: address_value})",
            "description": [
                "Address represents different types of TVM addresses: addr_none, addr_extern, addr_std and addr_var.\n",
                "Constructs an address of type addr_std with\nzero workchain id and given address value.\n",
                "Example:\n",
                "```\nuint address_value;\naddress addrStd = address(address_value);\n```\n"
            ]
        },
        "address.makeAddrStd": {
            "prefix": "address.makeAddrStd",
            "body": "address.makeAddrStd(${1: workchainId}, ${2: address})",
            "description": "Constructs an address of type addr_std\nwith given workchain id wid and value address_value.\n"
        },
        "address.makeAddrNone": {
            "prefix": "address.makeAddrNone",
            "body": "address.makeAddrNone()",
            "description": "Constructs an address of type addr_none.\n"
        },
        "address.makeAddrExtern": {
            "prefix": "address.makeAddrExtern",
            "body": "address.makeAddrExtern(${1: addrNumber}, ${2: bitCnt})",
            "description": "Constructs an address of type addr_extern with given value with bitCnt bit length.\n"
        },
        "<address>.wid": {
            "prefix": ".wid",
            "body": ".wid()",
            "description": [
                "```\n<address>.wid returns (int8);\n```\n",
                "Returns the workchain id of addr_std or addr_var. Throws \"range check error\" exception (error code equal to 5) for another address types."
            ]
        },
        "<address>.value": {
            "prefix": ".value",
            "body": ".value()",
            "description": [
                "```\n<address>.value returns (uint);\n```\n",
                "Returns the address value of addr_std or addr_var if addr_var has 256-bit\naddress value. Throws \"range check error\" exception (error code equal to 5) for another address types.\n"
            ]
        },
        "<address>.balance": {
            "prefix": ".balance",
            "body": "balance",
            "description": [
                "```\naddress(this).balance returns (uint128);\n```\n",
                "Returns the balance of this contract in nanotons.\n"
            ]
        },
        "<address>.currencies": {
            "prefix": ".currencies",
            "body": "currencies",
            "description": [
                "```\naddress(this).currencies returns (ExtraCurrencyCollection);\n```\n",
                "Returns currencies on the balance of this contract.\n"
            ]
        },
        "<address>.getType": {
            "prefix": ".getType",
            "body": ".getType()",
            "description": [
                "```\n<address>.getType() returns (uint8);\n```\n",
                "Returns type of the address:\n0 - addr_none 1 - addr_extern 2 - addr_std"
            ]
        },
        "<address>.isStdZero": {
            "prefix": ".isStdZero",
            "body": ".isStdZero()",
            "description": [
                "```\n<address>.isStdZero() returns (bool);\n```\n",
                "Returns the result of comparison between this address with zero address of type addr_std.\n"
            ]
        },
        "<address>.isStdAddrWithoutAnyCast": {
            "prefix": ".isStdAddrWithoutAnyCast",
            "body": ".isStdAddrWithoutAnyCast()",
            "description": [
                "```\n<address>.isStdAddrWithoutAnyCast() returns (bool);\n```\n",
                "Check whether this address is of type addr_std without any cast.\n"
            ]
        },
        "<address>.isExternZero": {
            "prefix": ".isExternZero",
            "body": ".isExternZero()",
            "description": [
                "```\n<address>.isExternZero() returns (bool);\n```\n",
                "Returns the result of comparison between this address with zero address of type addr_extern.\n"
            ]
        },
        "<address>.isNone": {
            "prefix": ".isNone",
            "body": ".isNone()",
            "description": [
                "```\n<address>.isNone() returns (bool);\n```\n",
                "Check whether this address is of type addr_none.\n"
            ]
        },
        "<address>.unpack": {
            "prefix": ".unpack",
            "body": ".unpack()",
            "description": [
                "```\n<address>.unpack() returns (int8 wid, uint256 value);\n```\n",
                "Parses \\<address> containing a valid MsgAddressInt (addr_std or addr_var), applies rewriting from the anycast (if present) to the same-length prefix of the address, and returns both the workchain wid and the 256-bit address value. If the address value is not 256-bit, or if \\<address> is not a valid serialization of MsgAddressInt, throws a cell deserialization exception.\n",
                "It's wrapper for opcode REWRITESTDADDR.\n",
                "Example:\n",
                "```\n(int8 wid, uint addr) = address(this).unpack();\n```\n"
            ]
        },
        "<address>.transfer": {
            "prefix": ".transfer",
            "body": ".transfer(${1:uint128 value}, ${2:bool bounce}, ${3:uint16 flag}, ${4:TvmCell body}, ${5:ExtraCurrencyCollection currencies});",
            "description": [
                "```\n<address>.transfer(",
                "\tuint128 value, ",
                "\tbool bounce,",
                "\tuint16 flag,",
                "\tTvmCell body,",
                "\tExtraCurrencyCollection currencies",
                ");\n```\n",
                "Sends an internal outbound message to defined address. All parameters can be omitted, except value.\n",                
                "--------\n",
                "Possible values of parameter flag:\n",
                " * 0 - message carries funds equal to the value parameter. Forward fee is subtracted from the value.",
                " * 128 - message carries all the remaining balance of the current smart contract. Parameter value is ignored. The contract's balance will be equal to zero after the message processing.",
                " * 64 - carries funds equal to the value parameter plus all the remaining value of the inbound message (that initiated the contract execution).\n",
                "--------\n",
                "Parameter flag can also be modified:\n",
                " * flag + 1 - means that the sender wants to pay transfer fees separately from contract's balance.",
                " * flag + 2 - means that any errors arising while processing this message during the action phase should be ignored. But if the message has wrong format, then the transaction fails and + 2 has no effect.",
                " * flag + 32 - means that the current account must be destroyed if its resulting balance is zero. For example, flag: 128 + 32 is used to send all balance and destroy the contract."
            ]
        },
        "<mapping>.min": {
            "prefix": ".min",
            "body": ".min()",
            "description": [
                "```\n<map>.min() returns (optional(KeyType, ValueType));\n```\n",
                "Computes the minimal key in the mapping and returns an optional value containing that key and the associated value. If mapping is empty, this function returns an empty optional.\n"
            ]
        },
        "<mapping>.max": {
            "prefix": ".max",
            "body": ".max()",
            "description": [
                "```\n<map>.max() returns (optional(KeyType, ValueType));\n```\n",
                "Computes the maximal key in the mapping and returns an optional value containing that key and the associated value. If mapping is empty, this function returns an empty optional.\n"
            ]
        },
        "<mapping>.next": {
            "prefix": ".next",
            "body": ".next(${1:KeyType key})",
            "description": [
                "```\n<map>.next(KeyType key) returns (optional(KeyType, ValueType));\n```\n",
                "Computes the maximal key in the mapping that is lexicographically greater than key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n",
                "Example:\n",
                "```\nmapping(uint8 => uint) m;\noptional(uint8, uint) = m.next(-1);\n```\n"
            ]
        },
        "<mapping>.prev": {
            "prefix": ".prev",
            "body": ".prev(${1:KeyType key})",
            "description": [
                "```\n<map>.prev(KeyType key) returns (optional(KeyType, ValueType));\n```\n",
                "Computes the minimal key in the mapping that is lexicographically less than key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n",
                "Example:\n",
                "```\nmapping(uint8 => uint) m;\noptional(uint8, uint) = m.prev(123);\n```\n"
            ]
        },
        "<mapping>.nextOrEq": {
            "prefix": ".nextOrEq",
            "body": ".nextOrEq(${1:KeyType key})",
            "description": [
                "```\n<map>.nextOrEq(KeyType key) returns (optional(KeyType, ValueType));\n```\n",
                "Computes the maximal key in the mapping that is lexicographically greater than or equal to key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n"
            ]
        },
        "<mapping>.prevOrEq": {
            "prefix": ".prevOrEq",
            "body": ".prevOrEq(${1:KeyType key})",
            "description": [
                "```\n<map>.prevOrEq(KeyType key) returns (optional(KeyType, ValueType));\n```\n",
                "Computes the minimal key in the mapping that is lexicographically less than or equal to key and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key. If KeyType is an integer type, argument for this functions can not possibly fit KeyType.\n"
            ]
        },
        "<mapping>.delMin": {
            "prefix": ".delMin",
            "body": ".delMin()",
            "description": [
                "```\n<map>.delMin() returns (optional(KeyType, ValueType));\n```\n",
                "If mapping is not empty then this function computes the minimal key of the mapping, deletes that key and the associated value from the mapping and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key.\n"
            ]
        },
        "<mapping>.delMax": {
            "prefix": ".delMax",
            "body": ".delMax()",
            "description": [
                "```\n<map>.delMax() returns (optional(KeyType, ValueType));\n```\n",
                "If mapping is not empty then this function computes the maximum key of the mapping, deletes that key and the associated value from the mapping and returns an optional value containing that key and the associated value. Returns an empty optional if there is no such key.\n"
            ]
        },
        "<mapping>.fetch": {
            "prefix": ".fetch",
            "body": ".fetch(${1:KeyType key})",
            "description": [
                "```\n<map>.fetch(KeyType key) returns (optional(ValueType));\n```\n",
                "Checks whether key presents in the mapping and returns an optional with the associated value. Returns an empty optional if there is no such key.\n"
            ]
        },
        "<mapping>.exists": {
            "prefix": ".exists",
            "body": ".exists(${1:KeyType key})",
            "description": [
                "```\n<map>.exists(KeyType key) returns (bool);\n```\n",
                "Returns a status flag whether key presents in the mapping.\n"
            ]
        },
        "<mapping>.empty": {
            "prefix": ".empty",
            "body": ".empty()",
            "description": [
                "```\n<map>.empty() returns (bool);\n```\n",
                "Returns a status flag whether the mapping is empty.\n"
            ]
        },
        "<mapping>.replace": {
            "prefix": ".replace",
            "body": ".replace(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "```\n<map>.replace(KeyType key, ValueType value) returns (bool);\n```\n",
                "Sets the value associated with key only if key presents in the mapping and returns the success flag.\n"
            ]
        },
        "<mapping>.add": {
            "prefix": ".add",
            "body": ".add(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "```\n<map>.add(KeyType key, ValueType value) returns (bool);\n```\n",
                "Sets the value associated with key only if key does not present in the mapping.\n"
            ]
        },
        "<mapping>.getSet": {
            "prefix": ".getSet",
            "body": ".getSet(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "```\n<map>.getSet(KeyType key, ValueType value) returns (optional(ValueType));\n```\n",
                "Sets the value associated with key, but also returns an optional with the old value associated with the key, if presents. Otherwise, returns an empty optional.\n"
            ]
        },
        "<mapping>.getAdd": {
            "prefix": ".getAdd",
            "body": ".getAdd(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "```\n<map>.getAdd(KeyType key, ValueType value) returns (optional(ValueType));\n```\n",
                "Sets the value associated with key, but only if key does not present in the mapping. Returns an optional with the old value without changing the dictionary if that value presents in the mapping, otherwise returns an empty optional.\n"
            ]
        },
        "<mapping>.getReplace": {
            "prefix": ".getReplace",
            "body": ".getReplace(${1:KeyType key}, ${2:ValueType value})",
            "description": [
                "```\n<map>.getReplace(KeyType key, ValueType value) returns (optional(ValueType));\n```\n",
                "Sets the value associated with key, but only if key presents in the mapping. On success, returns an optional with the old value associated with the key. Otherwise, returns an empty optional.\n"
            ]
        },
        "<mapping>.keys": {
            "prefix": ".keys",
            "body": ".keys()",
            "description": [
                "```\n<map>.keys() returns (KeyType[]);\n```\n",
                "Returns all mapping's keys. Note: these functions iterate over the whole mapping, thus the cost is proportional to the mapping's size.\n"
            ]
        },
        "<mapping>.values": {
            "prefix": ".values",
            "body": ".values()",
            "description": [
                "```\n<map>.values() returns (ValueType[]);\n```\n",
                "Returns all mapping's values. Note: these functions iterate over the whole mapping, thus the cost is proportional to the mapping's size.\n"
            ]
        },
        "require": {
            "prefix": "require",
            "body": "require(${1:bool condition}, ${2:uint errorCode}, ${3:Type exceptionArgument});",
            "description": [
                "```\nrequire(bool condition, [uint errorCode = 100, [Type exceptionArgument]]);\n```\n",
                "require function can be used to check the condition and throw an exception if the condition is not met. The function takes condition and optional parameters: error code (unsigned integer) and the object of any type.\n",
                "Example:\n",
                "```\nuint a = 5;\n```\n",
                "```\nrequire(a == 6, 101, \"a is not equal to six\");\n```\n"
            ]
        },
        "revert": {
            "prefix": "revert",
            "body": "revert(${1:uint errorCode}, ${2:Type exceptionArgument})",
            "description": [
                "```\nrevert(uint errorCode = 100, [Type exceptionArgument]);\n```\n",
                "revert function can be used to throw exceptions. The function takes an optional error code (unsigned integer) and the object of any type.\n",
                "Example:\n",
                "```\nrevert(102, \"We have a some problem\");\n```\n"
            ]
        },
        "receive": {
            "prefix": "receive",
            "body": "receive () external {\n\t$0\n}",
            "description": [
                "receive function is called in 2 cases:",
                "1. msg.body is empty.",
                "2. msg.body starts with 32-bit zero.",
                "\nThen message body may contain data, for example string with comment."
            ]
        },
        "fallback": {
            "prefix": "fallback",
            "body": "fallback () external {\n\t$0\n}",
            "description": [
                "fallback function is called when a body of an inbound internal/external message in such cases:",
                "1. The message contains a function id that the contract doesn't contain.",
                "2. Bit length of message between 1 and 31 (including).",
                "3. Bit length of message equals to zero, but the message contains reference(s)."
            ]
        },
        "onBounce": {
            "prefix": "onBounce",
            "body": "onBounce (TvmSlice body) external {\n\t$0\n}",
            "description": [
                "onBounce function is executed when contract receives a bounced inbound internal message. The message is generated by the network if the contract sends an internal message with bounce: true and",
                " * called contract doesn't exist;",
                " * called contract fails at storage/credit/computing phase (not at action phase!).",
                "\nThe message is generated only if the remaining message value is enough for sending one back.\n",
                "body is empty or contains at most 256 data bits of the original message (without references). The function id takes 32 bits and parameters can take at most 224 bits. It depends on the network config. If onBounce function is not defined then the contract does nothing on receiving a bounced inbound internal message.\n",
                "If the onBounce function throws an exception then another bounced messages are not generated."
            ]
        },
        "onTickTock": {
            "prefix": "onTickTock",
            "body": "onTickTock (bool isTock) external {\n\t$0\n}",
            "description": "onTickTock function is executed on tick/tock transaction. That transactions are automatically invoked for certain special accounts. For tick transactions isTock is false, for tock transactions - true.\n"
        },
        "onCodeUpgrade": {
            "prefix": "onCodeUpgrade",
            "body": "onCodeUpgrade () private {\n\t$0\n}",
            "description": "onCodeUpgrade function can have arbitrary set of arguments and should be executed after tvm.setcode() function call. In this function tvm.resetStorage() should be called if the set of state variables is changed in the new version of the contract. This function implicitly calls tvm.commit(). Then return from onCodeUpgrade TVM execution is finished with exit code 0.\n"
        },
        "afterSignatureCheck": {
            "prefix": "afterSignatureCheck",
            "body": "afterSignatureCheck (TvmSlice body, TvmCell message) private inline returns (TvmSlice){\n\t$0\n}",
            "description": "afterSignatureCheck function is used to define custom replay protection function instead of the default one. Never call tvm.commit() or tvm.accept() in the function because the function can be called before calling constructor.\n"
        },
        "msg.sender": {
            "prefix": "msg.sender",
            "body": "msg.sender",
            "description": [
                "```\nmsg.sender returns (address);\n```\n",
                "Returns:\n * sender of the message for internal message.\n* address(0) for external message.\n* address(0) for tick/tock transaction."
            ]
        },
        "msg.value": {
            "prefix": "msg.value",
            "body": "msg.value",
            "description": [
                "```\nmsg.value returns (uint128);\n```\n",
                "Returns:\n * Balance of the inbound message in nanotons for internal message.\n * 0 for external message.\n * Undefined value for tick/tock transaction."
            ]
        },
        "msg.currencies": {
            "prefix": "msg.currencies",
            "body": "msg.currencies",
            "description": [
                "```\nmsg.currencies returns (ExtraCurrencyCollection);\n```\n",
                "Collections of arbitrary currencies contained in the balance of the inbound message."
            ]
        },
        "msg.pubkey": {
            "prefix": "msg.pubkey",
            "body": "msg.pubkey()",
            "description": [
                "```\nmsg.pubkey() returns (uint256);\n```\n",
                "Returns sender's public key, obtained from the body of the external inbound message. If the message is not signed, msg.pubkey() returns 0. If the message is signed and message header (pragma AbiHeader) does not contain pubkey then msg.pubkey() is equal to tvm.pubkey()."
            ]
        },
        "msg.isInternal": {
            "prefix": "msg.isInternal",
            "body": "msg.isInternal",
            "description": "Returns whether the contract is called by internal message."
        },
        "msg.isExternal": {
            "prefix": "msg.isExternal",
            "body": "msg.isExternal",
            "description": "Returns whether the contract is called by external message."
        },
        "msg.isTickTock": {
            "prefix": "msg.isTickTock",
            "body": "msg.isTickTock",
            "description": "Returns whether the contract is called by tick/tock transactions."
        },
        "msg.createdAt": {
            "prefix": "msg.createdAt",
            "body": "msg.createdAt",
            "description": [
                "```\nmsg.createdAt returns (uint32);\n```\n",
                "Returns a field created_at of the external inbound message.\n"
            ]
        },
        "msg.data": {
            "prefix": "msg.data",
            "body": "msg.data",
            "description": [
                "```\nmsg.data returns (TvmSlice);\n```\n",
                "Returns the whole [Message](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L155).\n"
            ]
        },
        "msg.body": {
            "prefix": "msg.body",
            "body": "msg.body",
            "description": [
                "```\nmsg.body returns (TvmSlice);\n```\n",
                "Returns the payload (message body) of an inbound message.\n"
            ]
        },
        "msg.forwardFee": {
            "prefix": "msg.forwardFee",
            "body": "msg.forwardFee",
            "description": [
                "msg.forwardFee returns (varUint16);\n```\n",
                "Returns:\n - the forward fee for the internal inbound message.\n - 0 for the external inbound message.\n"
            ]
        },
        "msg.importFee": {
            "prefix": "msg.importFee",
            "body": "msg.importFee",
            "description": [
                "```\nmsg.importFee returns (varUint16);\n```\n",
                "Returns:\n - the field import_fee for external inbound message. Note: field import_fee is set offchain by user as they want and does not reflect the real import fee of the message.\n - 0 for the internal inbound message."
            ]
        },
        "msg.hasStateInit": {
            "prefix": "msg.hasStateInit",
            "body": "msg.hasStateInit",
            "description": [
                "```\nmsg.hasStateInit(bool);\n```\n",
                "Whether the internal/external inbound message contains field stateInit. Returns undefined value for tick/tock transaction. See [TL-B scheme](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb) of Message X."
            ]
        },
        "tvm.accept": {
            "prefix": "tvm.accept",
            "body": "tvm.accept();",
            "description": [
                "```\ntvm.accept();\n```\n",
                "Executes TVM instruction \"ACCEPT\" ([TVM](https://ton.org/tvm.pdf) - A.11.2. - F800). This instruction sets current gas limit to its maximal allowed value. This action is required to process external messages, which bring no value.\n"
            ]
        },
        "tvm.commit": {
            "prefix": "tvm.commit",
            "body": "tvm.commit();",
            "description": [
                "```\ntvm.commit();\n```\n",
                "Creates a \"check point\" of the state variables (by copying them from c7 to c4) and register c5. If the contract throws an exception at the computing phase then the state variables and register c5 will roll back to the \"check point\", and the computing phase will be considered \"successful\". If contract doesn't throw an exception, it has no effect.\n"
            ]
        },
        "tvm.rawCommit": {
            "prefix": "tvm.rawCommit",
            "body": "tvm.rawCommit();",
            "description": [
                "```\ntvm.rawCommit();\n```\n",
                "Creates a \"check point\" of the state variables but  doesn't copy the state variables from c7 to c4. It's a wrapper for opcode COMMIT. See TVM.\n",
                "Note: Don't use tvm.rawCommit() after tvm.accept() in processing external messages because you don't save from c7 to c4 the hidden state variable timestamp, which is used for replay protection.\n"
            ]
        },
        "tvm.getData": {
            "prefix": "tvm.getData",
            "body": "tvm.getData();",
            "description": [
                "```\ntvm.getData() returns (TvmCell);\n```\n",
                "It's an experimental function.\n A dual of the tvm.setData() returning value of c4 register. Getting a raw storage cell is useful when upgrading a new version of contract that introduces an altered data layout.\nManipulation with a raw storage cell requires an understanding of the way the compiler layouts the data. Refer to the description of tvm.setData() below to get more details.\n",
                "Note: state variables and replay protection timestamp stored in data cell have the same values that were before the transaction. See tvm.commit() how to update register c4.\n"
            ]
        },
        "tvm.setData": {
            "prefix": "tvm.setData",
            "body": "tvm.setData();",
            "description": [
                "```\ntvm.setData() returns (TvmCell);\n```\n",
                "It's an experimental function.Set cell data to register c4. \n",
                "Note, after returning from a public function all state variable from c7 will copy to c4 and tvm.setData will have no effect. Example of usage of such hint to set c4:\n",
                "```\nTvmCell data = ...;\n```\n",
                "tvm.setData(data); // set register c4\n",
                "tvm.rawCommit();   // save register c4 and c5\n",
                "revert(200);       // throw the exception to terminate the transaction\n",
                "Be careful with the hidden state variable timestamp and think about possibility of replaying external messages.\n"
            ]
        },
        "tvm.log": {
            "prefix": "tvm.log",
            "body": "tvm.log(${1:string log});",
            "description": [
                "```\ntvm.log(string log);\n```\n",
                "Dumps log string. This function is wrapper for TVM instructions PRINTSTR (for constant literal strings shorter than 16 symbols) and STRDUMP (for other strings). logtvm is an alias for tvm.log(string).\nNote: For long strings dumps only the first 127 symbols.\n",
                "Example:\n",
                "```\ntvm.log(\"Hello,world!\");\n```\n"
            ]
        },
        "logtvm": {
            "prefix": "logtvm",
            "body": "logtvm(${1:string log});",
            "description": [
                "```\nlogtvm(string log);\n```\n",
                "Dumps log string. This function is wrapper for TVM instructions PRINTSTR (for constant literal strings shorter than 16 symbols) and STRDUMP (for other strings). \nNote: For long strings dumps only the first 127 symbols.\n",
                "Example:\n",
                "```\nlogtvm(\"Hello,world!\");\n```\n"
            ]
        },
        "tvm.hexdump": {
            "prefix": "tvm.hexdump",
            "body": "tvm.hexdump(${1:T a});",
            "description": [
                "```\ntvm.hexdump(T a);\n```\n",
                "Dumps cell data or integer. Note that for cells this function dumps data only from the first cell. T must be an integer type or TvmCell.\n",
                "Example:\n",
                "```\ntvm.hexdump(123);\\\\Output: 7B\n"
            ]
        },
        "tvm.bindump": {
            "prefix": "tvm.bindump",
            "body": "tvm.bindump(${1:T a});",
            "description": [
                "```\ntvm.bindump(T a);\n```\n",
                "Dumps cell data or integer. Note that for cells this function dumps data only from the first cell. T must be an integer type or TvmCell.\n",
                "Example:\n",
                "```\ntvm.bindump(123);\\\\Output: 1111011\n```\n"
            ]
        },
        "tvm.setcode": {
            "prefix": "tvm.setcode",
            "body": "tvm.setcode(TvmCell newCode);",
            "description": [
                "```\ntvm.setcode(TvmCell newCode);\n```\n",
                "This command creates an output action that would change this smart contract code to that given by Cell newCode (this change will take effect only after the successful termination of the current run of the smart contract).\n"
            ]
        },
        "tvm.rawConfigParam": {
            "prefix": "tvm.rawConfigParam",
            "body": "tvm.rawConfigParam(${1:uint8 paramNumber});",
            "description": [
                "```\ntvm.rawConfigParam(uint8 paramNumber) returns (TvmCell cell, bool status);\n```\n",
                "Executes TVM instruction \"CONFIGPARAM\" (TVM - A.11.4. - F832). Returns the value of the global configuration parameter with integer index paramNumber as a cell and a boolean status.\n"
            ]
        },
        "tvm.configParam": {
            "prefix": "tvm.configParam",
            "body": "tvm.configParam(${1:uint8 paramNumber});",
            "description": [
                "```\ntvm.configParam(uint8 paramNumber) returns (TypeA a, TypeB b, ...);\n```\n",
                "Executes TVM instruction \"CONFIGPARAM\" (TVM - A.11.4. - F832). This command returns the value of the global configuration parameter with integer index paramNumber. Argument should be an integer literal. Supported paramNumbers: 1, 15, 17, 34.\n"
            ]
        },
        "tvm.rawReserve": {
            "prefix": "tvm.rawReserve",
            "body": "tvm.rawReserve(${1:uint value), ${2:uint8 flag});",
            "description": [
                "```\ntvm.rawReserve(uint value, uint8 flag);\ntvm.rawReserve(uint value, ExtraCurrencyCollection currency, uint8 flag);\n```\n",
                "Creates an output action which reserves reserve nanotons. It is roughly equivalent to create an outbound message carrying reserve nanotons to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. It's a wrapper for opcodes \"RAWRESERVE\" and \"RAWRESERVEX\".\n",
                "--------\n",
                "Let's denote:",
                " - original_balance is balance of the contract before the computing phase that is equal to balance of the contract before the transaction minus storage fee. Note: original_balance doesn't include msg.value and original_balance is not equal to address(this).balance.",
                " - remaining_balance is contract's current remaining balance at the action phase after some handled actions and before handing the \"rawReserve\" action.\n",
                "--------\n",
                "Let's consider how much nanotons (reserve) are reserved in all cases of flag:\n",
                "0 -> reserve = value nanotons.\n",
                "1 -> reserve = remaining_balance - value nanotons.\n",
                "2 -> reserve = min(value, remaining_balance) nanotons.\n",
                "3 = 2 + 1 -> reserve = remaining_balance - min(value, remaining_balance) nanotons.\n",
                "4 -> reserve = original_balance + value nanotons.\n",
                "5 = 4 + 1 -> reserve = remaining_balance - (original_balance + value) nanotons.\n",
                "6 = 4 + 2 -> reserve = min(original_balance + value, remaining_balance) = remaining_balance nanotons.\n",
                "7 = 4 + 2 + 1 -> reserve = remaining_balance - min(original_balance + value, remaining_balance) nanotons.\n",
                "12 = 8 + 4 -> reserve = original_balance - value nanotons.\n",
                "13 = 8 + 4 + 1 -> reserve = remaining_balance - (original_balance - value) nanotons.\n",
                "14 = 8 + 4 + 2 -> reserve = min(original_balance - value, remaining_balance) nanotons.\n",
                "15 = 8 + 4 + 2 + 1 -> reserve = remaining_balance - min(original_balance - value, remaining_balance) nanotons."
            ]
        },
        "tvm.hash": {
            "prefix": "tvm.hash",
            "body": "tvm.hash(${1|TvmCell cellTree,string data,bytes data,TvmSlice data|});",
            "description": [
                "```\ntvm.hash(TvmCell cellTree) returns (uint256);\ntvm.hash(string data) returns (uint256);\ntvm.hash(bytes data) returns (uint256);\ntvm.hash(TvmSlice data) returns (uint256);\n```\n",
                "Executes TVM instruction \"HASHCU\" or \"HASHSU\". It computes the representation hash of a given argument and returns it as a 256-bit unsigned integer. For string and bytes it computes hash of the tree of cells, which contains data, but not data itself. See sha256 to count hash of data.\n"
            ]
        },
        "tvm.checkSign": {
            "prefix": "tvm.checkSign",
            "body": "tvm.checkSign(${1|uint256 dataHash\\, uint256 SignHighPart\\, uint256 SignLowPart\\, uint256 pubkey,uint256 hash\\, TvmSlice signature\\, uint256 pubkey,TvmSlice data\\, TvmSlice signature\\, uint256 pubkey|});",
            "description": [         
            "```\ntvm.checkSign(uint256 dataHash, uint256 SignHighPart, uint256 SignLowPart, uint256 pubkey) returns (bool);\n```\n",
            "```\ntvm.checkSign(uint256 dataHash, TvmSlice signature, uint256 pubkey) returns (bool);\n```\n",
            "```\ntvm.checkSign(TvmSlice data, TvmSlice signature, uint256 pubkey) returns (bool);\n```\n",
            "Executes TVM instruction \"CHKSIGNU\" for variants 1 and 2. This command checks the Ed25519-signature of a dataHash using public key pubkey. Signature is represented by two uint256 SignHighPart and SignLowPart in the first variant and by a slice signature in the second variant. In the third variant executes TVM instruction \"CHKSIGNS\". This command checks Ed25519-signature of dataHash using public key pubkey. Signature is represented by a slice signature.\n"
            ]
        },
        "tvm.insertPubkey": {
            "prefix": "tvm.insertPubkey",
            "body": "tvm.insertPubkey(${1:TvmCell stateInit}, ${2:uint256 pubkey})",
            "description": [
                "```\ntvm.insertPubkey(TvmCell stateInit, uint256 pubkey) returns (TvmCell);\n```\n",
                "Inserts a public key into stateInit data field. If stateInit has wrong format then throws exception.\n"
            ]
        },
        "tvm.buildStateInit": {
            "prefix": "tvm.buildStateInit",
            "body": "tvm.buildStateInit(${1|TvmCell code\\, TvmCell data, TvmCell code\\, TvmCell data\\, uint8 splitDepth\\, {code: TvmCell code\\, data: TvmCell data\\, splitDepth: uint8 splitDepth\\, pubkey: uint256 pubkey\\, contr: contract Contract\\, varInit: {VarName0: varValue0\\, ...}}|})",
            "description": [
                "```\nreturns (TvmCell stateInit)\n```\n",
                "Generates a StateInit (TBLKCH - 3.1.7.) from code and data.\n"
            ]
        },
        "tvm.stateInitHash": {
            "prefix": "tvm.stateInitHash",
            "body": "stateInitHash(${1:uint256 codeHash}, ${2:uint256 dataHash}, ${3:uint16 codeDepth}, ${4:uint16 dataDepth})",
            "description": [
                "Calculates hash of the stateInit for given code and data specifications.\n",
                "Example:\n",
                "```\nTvmCell code = ...;\nTvmCell data = ...;\nuint codeHash = tvm.hash(code);\nuint dataHash = tvm.hash(data);\nuint16 codeDepth = code.depth();\nuint16 dataDepth = data.depth();\nuint256 hash = tvm.stateInitHash(codeHash, dataHash, codeDepth, dataDepth);\n```\n"
            ]
        },
        "tvm.buildDataInit": {
            "prefix": "tvm.buildDataInit",
            "body": "tvm.buildDataInit({pubkey: uint256 pubkey, contr: contract Contract, varInit: {VarName0: varValue0, ...}})",
            "description": [
                "Generates data field of the StateInit (TBLKCH - 3.1.7.). Parameters are the same as in tvm.buildStateInit().\n"
            ]
        },
        "tvm.deploy": {
            "prefix": "tvm.deploy",
            "body": "tvm.deploy(${1:TvmCell stateInit}, ${2:TvmCell payload}, ${3:uint128 value}, ${4:int8 wid})",
            "description": [
                "```\nreturns(address);\n```\n",
                "Deploys a new contract and returns the address of the deployed contract. This function may be useful if you want to write a universal contract that can deploy any contract.\n"
            ]
        },
        "tvm.code": {
            "prefix": "tvm.code",
            "body": "tvm.code()",
            "description": [
                "```\ntvm.code() returns (TvmCell);\n```\n",
                "Returns contract's code.\n"
            ]
        },
        "tvm.codeSalt": {
            "prefix": "tvm.codeSalt",
            "body": "tvm.codeSalt(${1:TvmCell code})",
            "description": [
                "```\ntvm.codeSalt(TvmCell code) returns (optional(TvmCell) optSalt);\n```\n",
                "If code contains salt then optSalt contains one. Otherwise, optSalt doesn't contain any value.\n"
            ]
        },
        "tvm.setCodeSalt": {
            "prefix": "tvm.setCodeSalt",
            "body": "setCodeSalt(${1:TvmCell code}, ${2:TvmCell salt})",
            "description": [
                "Inserts salt into code and returns new code newCode.\n",
                "```\ntvm.setCodeSalt(TvmCell code, TvmCell salt) returns (TvmCell newCode);\n```\n"
            ]
        },
        "tvm.pubkey": {
            "prefix": "tvm.pubkey",
            "body": "tvm.pubkey()",
            "description": [
                "```\ntvm.pubkey() returns (uint256);\n```\n",
                "Returns contract's public key, stored in contract data. If key is not set, function returns 0.\n"
            ]
        },
        "tvm.setPubkey": {
            "prefix": "tvm.setPubkey",
            "body": "tvm.setPubkey(${1:uint256 newPubkey})",
            "description": [
                "```\ntvm.setPubkey(uint256 newPubkey);\n```\n",
                "Set new contract's public key.\n"
            ]
        },
        "tvm.setCurrentCode": {
            "prefix": "tvm.setCurrentCode",
            "body": "tvm.setCurrentCode(${1:TvmCell newCode})",
            "description": [
                "```\ntvm.setCurrentCode(TvmCell newCode);\n```\n",
                "Changes this smart contract current code to that given by Cell newCode. Unlike tvm.setcode() this function changes code of the smart contract only for current TVM execution, but has no effect after termination of the current run of the smart contract.\n"
            ]
        },
        "tvm.resetStorage": {
            "prefix": "tvm.resetStorage",
            "body": "tvm.resetStorage()",
            "description": "Resets all state variables to their default values.\n"
        },
        "tvm.functionId": {
            "prefix": "tvm.functionId",
            "body": "tvm.functionId(${1:functionName})",
            "description": [
                "```\n// id of public function\ntvm.functionId(functionName) returns (uint32);\n\n// id of public constructor\ntvm.functionId(ContractName) returns (uint32);\n```\n",
                "Returns a function id (uint32) for public/external function or constructor.\n"
            ]
        },
        "tvm.encodeBody": {
            "prefix": "tvm.encodeBody",
            "body": "tvm.encodeBody(${1:function},${2:callbackFunction},${3: arg0, arg1, arg2, ...})",
            "description": [
                "```\ntvm.encodeBody(function, arg0, arg1, arg2, ...) returns (TvmCell);\ntvm.encodeBody(function, callbackFunction, arg0, arg1, arg2, ...) returns (TvmCell);\n```\n",
                "Constructs a function call message body that can be used as the payload for <address>.transfer(). If function is responsible then callbackFunction parameter must be set.\n"
            ]
        },
        "tvm.exit": {
            "prefix": "tvm.exit",
            "body": "tvm.exit()",
            "description": [
                "```\ntvm.exit();\n```\n",
                "Function are used to save state variables and to quickly terminate execution of the smart contract.\nExit code is equal to zero\n"
            ]
        },
        "tvm.exit1": {
            "prefix": "tvm.exit1",
            "body": "tvm.exit1()",
            "description": [
                "```\ntvm.exit1();\n```\n",
                "Function are used to save state variables and to quickly terminate execution of the smart contract.Exit code is equal to one\n"
            ]
        },
        "tvm.buildExtMsg": {
            "prefix": "tvm.buildExtMsg",
            "body": "tvm.buildExtMsg({\n\tdest: ${1:address},\n\ttime:${2:uint64},\n\texpire:${3:uint64},\n\tcall:{${4:functionIdentifier[, list_of_function_arguments]}},\n\tsign:${5:bool},\n\tpubkey:${6:optional(uint256)},\n\tcallbackId:${8:uint32},\n\tonErrorId:${9:uint32},\n\tstateInit:${10:TvmCell},\n\tsignBoxHandle:${11:optional(uint32)}\n\t\\});",
            "description": [
                "```\ntvm.buildExtMsg({\n    dest: address,\n    time: uint64,\n    expire: uint32,\n    call: {function, [callbackFunction,] arg0, arg1, arg2, ...},\n    sign: bool,\n    pubkey: optional(uint256),\n    callbackId: uint32,\n    onErrorId: uint32,\n    stateInit: TvmCell,\n    signBoxHandle: optional(uint32)\n})\nreturns (TvmCell);\n```\n",
                "Function should be used only offchain and intended to be used only in debot contracts. Allows creating an external inbound message, that calls the func function of the contract on address destination with specified function arguments.\n\nMandatory parameters that are used to form a src address field that is used for debots: \n - abiVer :  ABI version. \n - callbackId : identifier of the callback function.\n - onErrorId : identifier of the function that is called in case of error.\n - signBoxHandle : handle of the sign box entity, that engine will use to sign the message.\n\nThese parameters are stored in addr_extern and placed to the src field of the message. Message is of type ext_in_msg_info and src addr is of type addr_extern but stores special data:\n - callback id : 32 bits; \n - on error id : 32 bits;\n - abi version : 8 bits;\n - header mask : 3 bits in such order: time, expire, pubkey;\n - optional value signBoxHandle : 1 bit (whether value presents) + [32 bits].\n\nOther function parameters define fields of the message: \n - time : message creation timestamp. Used for replay attack protection, encoded as 64 bit Unix time in milliseconds.\n - expire : Unix time (in seconds, 32 bit) after that message should not be processed by contract.\n - pubkey : public key from key pair used for signing the message body. This parameter is optional and can be omitted.\n - sign : constant bool flag that shows whether message should contain signature. If set to true, message is generated with signature field filled with zeroes. This parameter is optional and can be omitted (in this case is equal to false).\nUser can also attach stateInit to the message using stateInit parameter.\n\nFunction throws an exception with code 64 if function is called with wrong parameters (pubkey is set and has value, but sign is false or omitted).\n"
            ]
        },
        "tvm.buildIntMsg": {
            "prefix": "tvm.buildIntMsg",
            "body": "tvm.buildIntMsg({\n\tdest:${1:address},\n\tvalue:${2:uint128},\n\tcall:{${4:function, [callbackFunction, ] arg0, arg1, arg2, ...}},\n\tbounce:${5:bool},\n\tcurrencies:${6:ExtraCurrencyCollection}\n\t\\});",
            "description": [
                "```\ntvm.buildIntMsg({\n    dest: address,\n    value: uint128,\n    call: {function, [callbackFunction,] arg0, arg1, arg2, ...},\n    bounce: bool,\n    currencies: ExtraCurrencyCollection\n    stateInit: TvmCell\n})\nreturns (TvmCell);\n```\n",
                "Generates an internal outbound message that contains function call. The cell can be used to send a message using tvm.sendrawmsg(). If the function is responsible then callbackFunction parameter must be set.\n\ndest, value and call parameters are mandatory. Another parameters can be omitted. See <address>.transfer() where these options and their default values are described.\n "
            ]
        },
        "tvm.sendrawmsg": {
            "prefix": "tvm.sendrawmsg",
            "body": "tvm.sendrawmsg(${1:TvmCell msg}, ${2:uint8 flag});",
            "description": [
                "```\ntvm.sendrawmsg(TvmCell msg, uint8 flag);\n```\n",
                "Send the internal/external message msg with flag. It's wrapper for opcode SENDRAWMSG ([TVM](https://ton.org/tvm.pdf) - A.11.10). Internal message msg can be generated by tvm.buildIntMsg().\n",
                "--------\n",
                "Possible values of parameter flag:\n",
                " * 0 - message carries funds equal to the value parameter. Forward fee is subtracted from the value.",
                " * 128 - message carries all the remaining balance of the current smart contract. Parameter value is ignored. The contract's balance will be equal to zero after the message processing.",
                " * 64 - carries funds equal to the value parameter plus all the remaining value of the inbound message (that initiated the contract execution).\n",
                "--------\n",
                "Parameter flag can also be modified:\n",
                " * flag + 1 - means that the sender wants to pay transfer fees separately from contract's balance.",
                " * flag + 2 - means that any errors arising while processing this message during the action phase should be ignored. But if the message has wrong format, then the transaction fails and + 2 has no effect.",
                " * flag + 32 - means that the current account must be destroyed if its resulting balance is zero. For example, flag: 128 + 32 is used to send all balance and destroy the contract."
            ]
        },
        "tvm.setGasLimit": {
            "prefix": "tvm.setGasLimit",
            "body": "tvm.setGasLimit(${1:uint g});",
            "description": [
                "tvm.setGasLimit(uint g);\n",
                "\nExecutes TVM instruction \"SETGASLIMIT\" (TVM - A.11.2).\nSets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that tvm.setGasLimit(...) with an argument g ≥ 263 − 1 is equivalent to tvm.accept().\ntvm.setGasLimit() is similar to tvm.accept(). tvm.accept() sets gas limit gl to the maximum possible value (depends on the network configuration parameters, usually is equal to 1_000_000 units of gas). tvm.setGasLimit() is generally used for accepting external messages and restricting max possible gas consumption. It may be used to protect from flood by \"bad\" owner in a contract that is used by multiple users. \nLet's consider some scenario:\n\n - Check whether msg.pubkey() != 0 and msg.pubkey() belongs to the list of trusted public keys;\n - Check whether m_floodCounter[msg.pubkey()] < 5 where m_floodCounter is count of pending operations of msg.pubkey() user.\n - tvm.setGasLimit(75_000); accept external message and set gas limit to 75_000.\n - ++m_floodCounter[msg.pubkey()]; increase count of pending operations for current users.\n - tvm.commit(); save current state if it needs\n - Do other things.\n\nSo if some user's public key will be stolen, then a hacker can spam with external messages and burn at most 5 * 75_000 units of gas instead of 5 * 1_000_000, because we use tvm.setGasLimit() instead of tvm.accept().\n"
            ]
        },
        "tvm.buyGas(uint value);": {
            "prefix": "tvm.buyGas",
            "body": "tvm.buyGas(${1:uint value});",
            "description": [
                "tvm.buyGas(uint value);\n",
                "Computes the amount of gas that can be bought for value nanotons, and sets gas limit accordingly in the same way as `tvm.setGasLimit()`.\n"
            ]
        },
        "math.min": {
            "prefix": "math.min",
            "body": "math.min(${1:T a, T b, ...});",
            "description": [
                "```\nmath.min(T a, T b, ...) returns (T);\n```\n",
                "Returns the minimal value of the passed arguments. \n"
            ]
        },
        "math.max": {
            "prefix": "math.max",
            "body": "math.max(${1:T a, T b, ...});",
            "description": [
                "```\nmath.max(T a, T b, ...) returns (T);\n```\n",
                "Returns the maximal value of the passed arguments. \n"
            ]
        },
        "math.minmax": {
            "prefix": "math.minmax",
            "body": "math.minmax(${1:T a, T b, ...});",
            "description": [
                "```\nmath.minmax(T a, T b) returns (T min, T max);\n```\n",
                "Returns minimal and maximal values of the passed arguments. T should be an integer or fixed point type\n",
                "Example:\n",
                "```\n(uint a, uint b) = math.minmax(20, 10); // (10, 20)\n```"
            ]
        },
        "math.abs": {
            "prefix": "math.abs",
            "body": "math.abs(${1|intM val,fixedMxN val|});",
            "description": [
                "```\nmath.abs(intM val) returns (intM);\nmath.abs(fixedMxN val) returns (fixedMxN);\n```\n",
                "Computes the absolute value of the given integer.\n"
            ]
        },
        "math.modpow2": {
            "prefix": "math.modpow2",
            "body": "math.modpow2(${1:uint value}, ${2:uint power});",
            "description": [
                "```\nmath.modpow2(uint value, uint power) returns (uint);\n```\n",
                "Computes the value modulo 2^power. Note that power should be a constant integer.\n",
                "Example:\n",
                "uint a = math.modpow2(10, 3); // a = 2\n"
            ]
        },
        "math.divc": {
            "prefix": "math.divc",
            "body": "math.divc(${1:T a}, ${2:T b});",
            "description": [
                "```\nmath.divc(T a, T b) returns (T);\n```\n",
                "Returns result of the division of two integers. T should be an integer or fixed point type. The return value is rounded ceiling\n"
            ]
        },
        "math.divr": {
            "prefix": "math.divr",
            "body": "math.divr(${1:T a}, ${2:T b});",
            "description": [
                "```\nmath.divr(T a, T b) returns (T);\n```\n",
                "Returns result of the division of two integers. T should be an integer or fixed point type. The return value is rounded nearest\n"
            ]
        },
        "math.muldiv": {
            "prefix": "math.muldiv",
            "body": "math.muldiv(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "```\nmath.muldiv(T a, T b, T c) returns (T);\n```\n",
                "Multiplies two values and then divides the result by a third value. The return value is rounded (nearest).\n"
            ]
        },
        "math.muldivr": {
            "prefix": "math.muldivr",
            "body": "math.muldivr(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "```\nmath.muldivr(T a, T b, T c) returns (T);\n```\n",
                "Multiplies two values and then divides the result by a third value. The return value is rounded (floor),\n"
            ]
        },
        "math.muldivc": {
            "prefix": "math.muldivc",
            "body": "math.muldivc(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "```\nmath.muldivc(T a, T b, T c) returns (T);\n```\n",
                "Multiplies two values and then divides the result by a third value. T is integer type. The return value is rounded(ceiling).\n"
            ]
        },
        "math.muldivmod": {
            "prefix": "math.muldivmod",
            "body": "math.muldivmod(${1:T a}, ${2:T b}, ${3:T c});",
            "description": [
                "```\nmath.muldivmod(T a, T b, T c) (T result, T remainder);\n```\n",
                "This instruction multiplies first two arguments, divides the result by third argument and returns the result and the remainder. Intermediate result is stored in the 514 bit buffer, and the final result is rounded to the floor.\n"
            ]
        },
        "math.divmod": {
            "prefix": "math.divmod",
            "body": "math.divmod(${1:T a}, ${2:T b});",
            "description": [
                "```\nmath.divmod(T a, T b) returns (T result, T remainder);\n```\n",
                "This instruction divides the first number by the second one and returns the result\nand the remainder. Result is rounded to the floor. T is integer type.\n"
            ]
        },
        "math.sign": {
            "prefix": "math.sign",
            "body": "math.sign(${1:T val});",
            "description": [
                "```\nmath.sign(T val) returns (int2);\n```\n",
                "Returns number in case of sign of the argument value val:\n * -1 if val is negative;\n * 0 if val is zero;\n * 1 if val is positive.\n"
            ]
        },
        "tx.timestamp": {
            "prefix": "tx.timestamp",
            "body": "tx.timestamp",
            "description": [
                "```\ntx.timestamp returns (uint64);\n```\n",
                "Returns the logical time of the current transaction.\n"
            ]
        },
        "tx.logicaltime": {
            "prefix": "tx.logicaltime",
            "body": "tx.logicaltime",
            "description": [
                "```\ntx.logicaltime returns (uint64);\n```\n",
                "Returns the logical time of the current transaction.\n"
            ]
        },
        "tx.storageFee": {
            "prefix": "tx.storageFee",
            "body": "tx.storageFee",
            "description": [
                "```\ntx.storageFee returns (uint120);\n```\n",
                "Returns the storage fee paid in the current transaction.\n"
            ]
        },
        "block.timestamp": {
            "prefix": "block.timestamp",
            "body": "block.timestamp",
            "description": [
                "```\nblock.timestamp returns (uint64);\n```\n",
                "Returns the current Unix time. Unix time is the same for the all transactions from one block.\n"
            ]
        },
        "block.logicaltime": {
            "prefix": "block.logicaltime",
            "body": "block.logicaltime",
            "description": [
                "```\nblock.logicaltime returns (uint64);\n```\n",
                "Returns the starting logical time of the current block.\n"
            ]
        },
        "now": {
            "prefix": "now",
            "body": "now",
            "description": [
                "Example:\n```\nuint start = now;\n```\n",
                "It is the number of seconds since the Epoch.\n"
            ]
        },
        "rnd.next": {
            "prefix": "rnd.next",
            "body": "rnd.next(${1:[Type limit]})",
            "description": [
                "```\nrnd.next([Type limit]) returns (Type);\n```\n",
                "Generates a new pseudo-random number.\n",
                "1. Returns uint256 number.",
                "2. If the first argument limit > 0 then function returns the value in the range 0..limit-1. Else if limit < 0 then the returned value lies in range limit..-1. Else if limit == 0 then it returns 0.\n",
                "Example:\n",
                "```\nuint256 r0 = rnd.next(); // 0..2^256-1\n```",
                "```\nuint8 r1 = rnd.next(100);  // 0..991\n```",
                "```\nint8 r2 = rnd.next(int8(100));  // 0..991\n```",
                "```\nint8 r3 = rnd.next(int8(-100)); // -100..-11\n```\n"
            ]
        },
        "rnd.getSeed": {
            "prefix": "rnd.getSeed",
            "body": "rnd.getSeed()",
            "description": [
                "```\nrnd.getSeed() returns (uint256);\n```\n",
                "Returns the current random seed.\n"
            ]
        },
        "rnd.setSeed": {
            "prefix": "rnd.setSeed",
            "body": "rnd.setSeed()",
            "description": [
                "```\nrnd.setSeed(${1:uint256 x});\n```\n",
                "Sets the random seed to x.\n"
            ]
        },
        "rnd.shuffle": {
            "prefix": "rnd.shuffle",
            "body": "rnd.shuffle(${1:uint someNumber(optional)})",
            "description": [
                "Randomizes the random seed.\n",
                "\n```\n//(1)\nrnd.shuffle(uint someNumber);\n//(2)\nrnd.shuffle();\n```\n",
                "1. Mixes the random seed and someNumber\nrnd.shuffle(uint someNumber);",
                "2. Mixes the random seed and the logical time of the current transaction."
            ]
        },
        "abi.encode": {
            "prefix": "abi.encode",
            "body": "abi.encode(${1:TypeA a}, ${2:TypeB b})",
            "description": [
                "Creates cell from the values.\n",
                "```\nabi.encode(TypeA a, TypeB b, ...) returns (TvmCell /*cell*/);\n```\n",
                "Example:\n",
                "```\nTvmCell cell = abi.encode(uint(1), uint(2), uint(3), uint(4));\n```\n"
            ]
        },
        "abi.decode": {
            "prefix": "abi.decode",
            "body": "abi.decode(${1:TvmCell}, (${2:TypeA}, ${3:TypeB}))",
            "description": [
                "```\nabi.decode(TvmCell cell, (TypeA, TypeB, ...)) returns (TypeA /*a*/, TypeB /*b*/, ...);\n```\n",
                "Decodes the cell and returns the values. Note: all types must be set in abi.decode. Otherwise, abi.decode throws an exception.",
                "Example:\n",
                "```\n(uint a, uint b, uint c, uint d) = abi.decode(cell, (uint, uint, uint, uint));\n```\n"
            ]
        },
        "gosh.applyBinPatchQ": {
            "prefix": "gosh.applyBinPatchQ",
            "body": "gosh.applyBinPatchQ(${1:bytes oldText}, ${2:bytes patch})",
            "description": [
                "```\ngosh.applyBinPatchQ(bytes oldText, bytes patch) returns (optional(bytes) newText);\n```\n",
                "Applies patch to compressed strings. If it's impossible (bad patch), gosh.applyBinPatchQ returns null.\n",
                "Example:\n",
                "```\nbytes oldText = ...;\n```\n",
                "```\nbytes patch = ...;\n```\n",
                "```\noptional(bytes) newText = gosh.applyBinPatchQ(oldText, patch);\n```\n"
            ]            
        },
        "gosh.applyPatchQ": {
            "prefix": "gosh.applyPatchQ",
            "body": "gosh.applyPatchQ(${1:string oldText}, ${2:string patch})",
            "description": [
                "```\ngosh.applyPatchQ(string oldText, string patch) returns (optional(string) newText);\n```\n",
                "Applies patch to the oldText. If it's impossible (bad patch), gosh.applyPatchQ returns null.\n",
                "Example:\n",
                "```\nstring oldText = ...;\n```\n",
                "```\nstring patch = ...;\n```\n",
                "```\noptional(string) newText = gosh.applyPatch(oldText, patch);\n```\n"
            ]
        },
        "gosh.applyBinPatch": {
            "prefix": "gosh.applyBinPatch",
            "body": "gosh.applyBinPatch(${1:bytes oldText}, ${2:bytes patch})",
            "description": [
                "```\ngosh.applyBinPatch(bytes oldText, bytes patch) returns (bytes newText);\n```\n",
                "Applies patch to compressed binary arrays. If it's impossible (bad patch), gosh.applyBinPatch throws an exception with type check error code (-8).\n",
                "Example:\n",
                "```\nbytes oldText = ...;\n```\n",
                "```\nbytes patch = ...;\n```\n",
                "```\nbytes newText = gosh.applyBinPatch(oldText, patch);\n```\n"
            ]            
        },
        "gosh.applyPatch": {
            "prefix": "gosh.applyPatch",
            "body": "gosh.applyPatch(${1:string oldText}, ${2:string patch})",
            "description": [
                "```\ngosh.applyPatch(string oldText, string patch) returns (string newText);\n```\n",
                "Applies patch to the oldText. If it's impossible (bad patch), gosh.applyPatch throws an exception with type check error code (-8).\n",
                "Example:\n",
                "```\nstring oldText = ...;\n```\n",
                "```\nstring patch = ...;\n```\n",
                "```\nstring newText = gosh.applyPatch(oldText, patch);\n```\n"
            ]
        },
        "gosh.unzip": {
            "prefix": "gosh.unzip",
            "body": "gosh.unzip(${1:bytes zip})",
            "description": [
                "```\ngosh.unzip(bytes zip) returns (optional(string) text);\n```\n",
                "Revert zip compression\n"
            ]
        },
        "gosh.zipDiff": {
            "prefix": "gosh.zipDiff",
            "body": "gosh.zipDiff(${1:bytes oldText}, ${2:bytes newText})",
            "description": [
                "```\ngosh.zipDiff(bytes oldText, bytes newText) returns (bytes patch);\n```\n",
                "It's the same as gosh.diff but it calculates patch between compressed string.\n"
            ]
        },
        "gosh.applyZipBinPatchQ": {
            "prefix": "gosh.applyZipBinPatchQ",
            "body": "gosh.applyZipBinPatchQ(${1:bytes oldText}, ${2:bytes patch})",
            "description": [
                "```\ngosh.applyZipBinPatchQ(bytes oldText, bytes patch) returns (optional(bytes) newText);\n```\n",                
                "These are the same as gosh.applyPatchQ but this functions is applied patch to compressed binary arrays.\n"                
            ]            
        },
        "gosh.applyZipPatchQ": {
            "prefix": "gosh.applyZipPatchQ",
            "body": "gosh.applyZipPatchQ(${1:bytes oldText}, ${2:bytes patch})",
            "description": [
                "```\ngosh.applyZipPatchQ(bytes oldText, bytes patch) returns (optional(bytes) newText);\n```\n",
                "These are the same as gosh.applyPatchQ but this functions is applied to compressed string.\n"
            ]
        },   
        "gosh.applyZipBinPatch": {
            "prefix": "gosh.applyZipBinPatch",
            "body": "gosh.applyZipBinPatch(${1:bytes oldText}, ${2:bytes patch})",
            "description": [
                "```\ngosh.applyZipBinPatch(bytes oldText, bytes patch) returns (bytes newText);\n```\n",                
                "These are the same as gosh.applyPatch but this function is applied patch to compressed binary arrays.\n"                
            ]            
        },
        "gosh.applyZipPatch": {
            "prefix": "gosh.applyZipPatch",
            "body": "gosh.applyZipPatch(${1:bytes oldText}, ${2:bytes patch})",
            "description": [
                "```\ngosh.applyZipPatch(bytes oldText, bytes patch) returns (bytes newText);\n```\n",
                "These are the same as gosh.applyPatch but this function is applied to compressed string.\n"
            ]
        },
        "gosh.diff": {
            "prefix": "gosh.diff",
            "body": "gosh.diff(${1:string oldText}, ${2:string newText})",
            "description": [
                "```\ngosh.diff(string oldText, string newText) returns (string patch);\n```\n",
                "Calculates <a href=\"https://en.wikipedia.org/wiki/Diff\">patch</a> between oldText and newText.\n",
                "Example:\n",
                "```\nstring oldText = ...;\n```\n",
                "```\nstring newText = ...;\n```\n",
                "```\nstring patch = gosh.diff(oldText, newText);\n```\n"
            ]
        },
        "gosh.zip": {
            "prefix": "gosh.zip",
            "body": "gosh.zip(${1:string text})",
            "description": [
                "```\ngosh.zip(string text) returns (bytes zip);\n```\n",
                "Converts the text to compressed bytes\n"
            ]
        },
        "selfdestruct": {
            "prefix": "selfdestruct",
            "body": "selfdestruct(${1:address dest_addr})",
            "description": [
                "```\nselfdestruct(address dest_addr);\n```\n",
                "Creates and sends the message that carries all the remaining balance of the current smart contract and destroys the current account.\n"
            ]
        },
        "sha256": {
            "prefix": "sha256",
            "body": "sha256(${1|TvmSlice slice, bytes b, string str|})",
            "description": [
                "sha256(TvmSlice slice) returns (uint256)\n",
                "sha256(bytes b) returns (uint256)\n",
                "sha256(string str) returns (uint256)\n",
                "1. Compute the SHA-256 hash. If the bit length of slice is not divisible by eight, throws a cell underflow exception. References of slice are not used to compute the hash. Only data bits located in the root cell of slice are used.  ",
                "2. Compute the SHA-256 hash only for the first 127 bytes. If bytes.length > 127 then b[128], b[129], b[130] ... elements are ignored.",
                "3. Same as for bytes: only the first 127 nbytes are taken into account.\n"
            ]
        },
        "gasToValue": {
            "prefix": "gasToValue",
            "body": "gasToValue(${1:uint128 gas}, ${2:int8 wid(optional)})",
            "description": [
                "gasToValue(uint128 gas) returns (uint128 value);\n",
                "gasToValue(uint128 gas, int8 wid) returns (uint128 value)\n",
                "Returns worth of gas in workchain wid. Throws an exception if wid doesn't equal 0 and -1.\n"
            ]
        },
        "valueToGas": {
            "prefix": "valueToGas",
            "body": "valueToGas(${1:uint128 value}, ${2:int8 wid(optional)})",
            "description": [
                "valueToGas(uint128 value) returns (uint128 gas);\n",
                "valueToGas(uint128 value, int8 wid) returns (uint128 gas)\n",
                "Returns how much gas could be bought on value nanotons in workchain wid. Throws an exception if wid doesn't equal 0 and -1.\n"
            ]
        },
        "gasLeft": {
            "prefix": "gasLeft",
            "body": "gasLeft()",
            "description": [                
                "```\ngasLeft returns (uint64);\n```\n",                                 
                "Returns the remaining gas. Supported only if CapGasRemainingInsn capability is set.\n"
            ]
        },
        "constant": {
            "prefix": "constant",
            "body": "constant ${1:name} = ${0:value};",
            "description": [
                "```\nuint constant cost = 100;\n```\n",
                "For constant variables, the value has to be a constant at compile time and this value is substituted where the variable is used. The value has to be assigned where the variable is declared.\n"
            ]
        },
        "static": {
            "prefix": "static",
            "body": "static ${0:name};",
            "description": [
                "Static state variables are used in generation of the contract origin state. Such variables can be set while deploying contract from contract (onchain) or by tvm-linker (offchain).\n",
                "Example:\n",
                "```\nuint static a; //ok\n```",
                "```\nuint static b = 123; // error\n```"
            ]
        },
        "inline": {
            "prefix": "inline",
            "body": "inline",
            "description": [
                "Instructs the compiler to insert a copy of the function body into each place where the function is called. Keyword can be used only for private and internal functions.\n",
                "Example:\n",
                "```\n// This function is called as usual function.\nfunction getSum(uint a, uint b) public returns (uint) {\n    return sum(a, b);\n}\n\n// Code of this function is inserted to the place of call.\nfunction sum(uint a, uint b) private inline returns (uint) {\n    return a + b;\n}\n```\n"
            ]
        },
        "emptyMap": {
            "prefix": "emptyMap",
            "body": "emptyMap",
            "description": [
                "Keyword emptyMap is a constant that is used to indicate a mapping of arbitrary type without values.\n",
                "Example:\n",
                "```\nstruct Stakes {\n    uint total;\n    mapping(uint => uint) stakes;\n}\n\n// create struct with empty mapping 'stakes'\nStakes stakes = Stakes({stakes: emptyMap, total: 200});\n```\n"
            ]
        },
        "functionID": {
            "prefix": "functionID",
            "body": "functionID(${1:uint32 ID})",
            "description": [
                "functionID keyword allows setting identifier of the function manually. Each public function has unique 32-bit id. id==0 is reserved for receive function. If functionID is not used then function id is calculated as a hash of the function signature. In general, there is no need to set function id manually.\n",
                "Example:\n",
                "```\nfunction f() public pure functionID(123) {\n    /*...*/\n}\n```\n"
            ]
        },
        "externalMsg": {
            "prefix": "externalMsg",
            "body": "externalMsg",
            "description": [
                "Specify which messages the function can handle. If is called by internal message, the function throws an exception with code 71.",
                "Example:\n",
                "```\nfunction f() public externalMsg { // this function receives only external messages \n    /*...*/\n}\n\n// Note: keyword 'external' specifies function visibility\nfunction ff() external externalMsg { // this function receives only external messages also  \n    /*...*/\n}\n```\n"
            ]
        },
        "internalMsg": {
            "prefix": "internalMsg",
            "body": "internalMsg",
            "description": [
                "Specify which messages the function can handle. If is called by external message, the function throws an exception with code 72.",
                "Example:\n",
                "```\nfunction g() public internalMsg { // this function receives only internal messages\n    /*...*/\n}\n\n// These function receives internal and external messages.\nfunction fun() public { /*...*/ }\n```\n"
            ]
        },
        "nano": {
            "prefix": "nano",
            "body": "nano",
            "description": [
                "1 nano = 0.000000001 ever or 1e-9 ever\n"
            ]
        },
        "nanoever": {
            "prefix": "nanoever",
            "body": "nanoever",
            "description": [
                "1 nanoever == 0.000000001 ever or 1e-9ton\n"
            ]
        },
        "Ever": {
            "prefix": "Ever",
            "body": "Ever",
            "description": [
                "1 Ever == 1e9 nanoever\n"
            ]
        },
        "micro": {
            "prefix": "micro",
            "body": "micro",
            "description": [
                "1 Ever == 1e-6 ever\n"
            ]
        },
        "microever": {
            "prefix": "microever",
            "body": "microever",
            "description": [
                "1 microever == 1e-6 ever\n"
            ]
        },
        "milli": {
            "prefix": "milli",
            "body": "milli",
            "description": [
                "1 milli == 1e-3 ever\n"
            ]
        },
        "milliever": {
            "prefix": "milliever",
            "body": "milliever",
            "description": [
                "1 milliever == 1e-3 ever\n"
            ]
        },
        "kiloever": {
            "prefix": "kiloever",
            "body": "kiloever",
            "description": [
                "1 kiloever == 1e3 ever\n"
            ]
        },
        "kEver": {
            "prefix": "kEver",
            "body": "kEver",
            "description": [
                "1 kEver == 1e3 ever\n"
            ]
        },
        "megaever": {
            "prefix": "megaever",
            "body": "megaever",
            "description": [
                "1 kEver == 1e6 ever\n"
            ]
        },
        "MEver": {
            "prefix": "MEver",
            "body": "MEver",
            "description": [
                "1 MEver == 1e6 ever\n"
            ]
        },
        "gigaever": {
            "prefix": "gigaever",
            "body": "gigaever",
            "description": [
                "1 gigaever == 1e6 ever\n"
            ]
        },
        "GEver": {
            "prefix": "GEver",
            "body": "GEver",
            "description": [
                "1 GEver == 1e6 ever\n"
            ]
        },
        "nanoton": {
            "prefix": "nanoton",
            "body": "nanoton",
            "description": [
                "1 nanoton == 0.000000001 ton or 1e-9ton\n"
            ]
        },
        "microton": {
            "prefix": "microton",
            "body": "microton",
            "description": [
                "1 microton == 1e-6 ton\n"
            ]
        },
        "milliton": {
            "prefix": "milliton",
            "body": "milliton",
            "description": [
                "1 milliton == 1e-3 ton\n"
            ]
        },
        "kiloton": {
            "prefix": "kiloton",
            "body": "kiloton",
            "description": [
                "1 kiloton == 1e3 ton\n"
            ]
        },
        "kTon": {
            "prefix": "kTon",
            "body": "kTon",
            "description": [
                "1 kTon == 1e3 ton\n"
            ]
        },
        "megaton": {
            "prefix": "megaton",
            "body": "megaton",
            "description": [
                "1 kTon == 1e6 ton\n"
            ]
        },
        "MTon": {
            "prefix": "MTon",
            "body": "MTon",
            "description": [
                "1 MTon == 1e6 ton\n"
            ]
        },
        "gigaton": {
            "prefix": "gigaton",
            "body": "gigaton",
            "description": [
                "1 gigaton == 1e6 ton\n"
            ]
        },
        "GTon": {
            "prefix": "GTon",
            "body": "GTon",
            "description": [
                "1 GTon == 1e6 ton\n"
            ]
        },
        "<optional(Type)>.set": {
            "prefix": ".set",
            "body": ".set(${1:Type value})",
            "description": [
                "```\n<optional(Type)>.set(Type value);\n```\n",
                "Replaces the content of the optional with the contents of other."
            ]
        },
        "<optional(Type)>.reset": {
            "prefix": ".reset",
            "body": ".reset()",
            "description": [
                "```\n<optional(Type)>.reset();\n```\n",
                "Deletes the content of the optional."
            ]
        },
        "<TvmSlice>.decode": {
            "prefix": ".decode",
            "body": ".decode(${1:TypeA}, ${2:TypeB} ...)",
            "description": [
                "DEPRECATED. Use .load instead.\n",
                "```\n<TvmSlice>.decode(TypeA, TypeB, ...) returns (TypeA a, TypeB b, ...);\n```\n",
                "Supported types: `uintN`, `intN`, `bytesN`, `bool`, `ufixedMxN`, `fixedMxN`, `address`, `contract`, `TvmCell`, `bytes`, `string`, `mapping`, `ExtraCurrencyCollection`, `array`, `optional` and `struct`\n",
                "Example:\n",
                "```\nTvmSlice slice = ...;\n```\n",
                "```\n(uint8 a, uint16 b) = slice.decode(uint8, uint16);\n```\n",
                "```\n(uint16 num0, uint32 num1, address addr) = slice.decode(uint16, uint32, address);\n```\n"
            ]
        },
        "<TvmSlice>.decodeQ": {
            "prefix": ".decodeQ",
            "body": "decodeQ(${1:TypeA}, ${2:TypeB} ...)",
            "description": [
                "DEPRECATED. Use .loadQ instead.\n",
                "```\n<TvmSlice>.decodeQ(TypeA, TypeB, ...) returns (optional(TypeA, TypeB, ...));\n```\n",
                "Supported types: `uintN`, `intN`, `bytesN`, `bool`, `ufixedMxN`, `fixedMxN`, `address`, `contract`, `TvmCell`, `bytes`, `string`, `mapping`, `ExtraCurrencyCollection`, `array`\n",
                "Example:\n",
                "```\nTvmSlice slice = ...;\n```\n",
                "```\noptional(uint) a = slice.decodeQ(uint);\n```\n",
                "```\noptional(uint8, uint16) b = slice.decodeQ(uint8, uint16);\n```\n"
            ]
        },
        "<TvmSlice>.load": {
            "prefix": ".load",
            "body": "load(${1:TypeA}, ${2:TypeB} ...)",
            "description": [
                "```\n<TvmSlice>.load(TypeA, TypeB, ...) returns (TypeA a, TypeB b, ...);\n```\n",
                "Sequentially loads values of the specified types from the `TvmSlice`. Supported types: `uintN`, `intN`, `bytesN`, `bool`, `ufixedMxN`, `fixedMxN`, `address`, `contract`, `TvmCell`, `bytes`, `string`, `mapping`, `ExtraCurrencyCollection`, `array`, `optional` and `struct`\n",
                "Note: if all the argument types can't be loaded from the slice a cell underflow exception is thrown.\n",
                "Example:\n",
                "```\nTvmSlice slice = ...;\n```\n",
                "```\n(uint8 a, uint16 b) = slice.load(uint8, uint16);\n```\n",
                "```\n(uint16 num0, uint32 num1, address addr) = slice.load(uint16, uint32, address);\n```\n"
            ]
        },
        "<TvmSlice>.loadQ": {
            "prefix": ".loadQ",
            "body": "loadQ(${1:TypeA}, ${2:TypeB} ...)",
            "description": [
                "```\n<TvmSlice>.loadQ(TypeA, TypeB, ...) returns (optional(TypeA, TypeB, ...));\n```\n",
                "Sequentially load values of the specified types from the `TvmSlice` if the `TvmSlice` holds sufficient data for all specified types. Otherwise, returns `null`.\n",
                "Example:\n",
                "```\nTvmSlice slice = ...;\n```\n",
                "```\noptional(uint) a = slice.loadQ(uint);\n```\n",
                "```\noptional(uint8, uint16) b = slice.loadQ(uint8, uint16);\n```\n"
            ]
        },
        "TvmCell": {
            "prefix": "TvmCell",
            "body": "TvmCell ${1:name}",
            "description": [
                "TvmCell represents TVM cell ([TVM](https://ton.org/tvm.pdf) - 1.1.3). The compiler defines the following operators and functions to work with this type:\n",
                "Operators:\n",
                " * Comparisons: ==, != (evaluate to bool)\n",
                "Methods:\n",
                " ```\n <TvmCell>.depth() \n```",
                " ```\n <TvmCell>.dataSize() \n```",
                " ```\n <TvmCell>.dataSizeQ() \n```",
                " ```\n <TvmCell>.toSlice() \n```"
            ]
        },
        "TvmSlice": {
            "prefix": "TvmSlice",
            "body": "TvmSlice ${1:name}",
            "description": [
                "TvmSlice represents TVM cell slice ([TVM](https://ton.org/tvm.pdf) - 1.1.3). The compiler defines the following operators and functions to work with this type:\n",
                "Operators:\n",
                " * Comparisons: <=, <, ==, !=, >=, > (evaluate to bool). Note: only bit data from the root cells are compared, references are ignored.\n",
                "Methods:\n",
                " ```\n <TvmSlice>.empty() \n```",
                " ```\n <TvmSlice>.size() \n```",
                " ```\n <TvmSlice>.dataSize \n```",
                " ```\n <TvmSlice>.dataSizeQ() \n```",
                " ```\n <TvmSlice>.bits() \n```",
                " ```\n <TvmSlice>.refs() \n```",
                " ```\n <TvmSlice>.bitsAndRefs() \n```",
                " ```\n <TvmSlice>.depth() \n```",
                " ```\n <TvmSlice>.hasNBits(), <TvmSlice>.hasNRefs() and <TvmSlice>.hasNBitsAndRefs() \n```",
                " ```\n <TvmSlice>.compare()\n ```",
                "TvmSlice load primitives:\n",
                " ```\n<TvmSlice>.decode() //DEPRECATED\n```",
                " ```\n<TvmSlice>.decodeQ() //DEPRECATED\n```",
                " ```\n<TvmSlice>.load() \n```",
                " ```\n<TvmSlice>.loadQ() \n```",
                " ```\n<TvmSlice>.loadIntLEN()\n```",
                " ```\n<TvmSlice>.loadIntLENQ()\n```",
                " ```\n<TvmSlice>.loadRef() \n```",
                " ```\n<TvmSlice>.loadRefAsSlice() \n```",
                " ```\n<TvmSlice>.loadSigned() \n```",
                " ```\n<TvmSlice>.loadUnsigned() \n```",
                " ```\n<TvmSlice>.loadTons() \n```",
                " ```\n<TvmSlice>.loadSlice() \n```",
                " ```\n<TvmSlice>.decodeFunctionParams() \n```",
                " ```\n<TvmSlice>.skip() \n```",
                " ```\n<TvmSlice>.loadZeroes() \n```",
                " ```\n<TvmSlice>.loadOnes() \n```",
                " ```\n<TvmSlice>.loadSame() \n```"
            ]
        },
        "TvmBuilder": {
            "prefix": "TvmBuilder",
            "body": "TvmBuilder ${1:name}",
            "description": [
                "TvmBuilder represents TTVM cell builder ([TVM](https://ton.org/tvm.pdf) - 1.1.3). The compiler defines the following functions to work with this type:\n",
                " ```\n <TvmBuilder>.toSlice() \n```",
                " ```\n <TvmBuilder>.toCell() \n```",
                " ```\n <TvmBuilder>.bits() \n```",
                " ```\n <TvmBuilder>.refs() \n```",
                " ```\n <TvmBuilder>.bitsAndRefs() \n```",
                " ```\n <TvmBuilder>.remBits() \n```",
                " ```\n <TvmBuilder>.remRefs() \n```",
                " ```\n <TvmBuilder>.remBitsAndRefs() \n```",
                " ```\n <TvmBuilder>.depth() \n```",
                " ```\n <TvmBuilder>.store() \n```",
                " ```\n <TvmBuilder>.storeOnes() \n```",
                " ```\n <TvmBuilder>.storeZeroes() \n```",
                " ```\n <TvmBuilder>.storeSame() \n```",
                " ```\n <TvmBuilder>.storeSigned() \n```",
                " ```\n <TvmBuilder>.storeUnsigned() \n```",
                " ```\n <TvmBuilder>.storeIntLEN \n```",                
                " ```\n <TvmBuilder>.storeUintLEN \n```",                
                " ```\n <TvmBuilder>.storeRef() \n```",
                " ```\n <TvmBuilder>.storeTons() \n```",
                " ```\n <TvmBuilder>.storeUint() \n```",
                " ```\n <TvmBuilder>.storeInt() \n```"
            ]
        },
        "AddressInput.get": {
            "prefix": "AddressInput.get",
            "body": "AddressInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\");",
            "description": [
                "Allows to get TON standard address selected by user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback",
                " - prompt: bytes — utf-8 string to print to the user before input.",
                "\nReturns:",
                " - value: address — address selected by user.",
                "\nExample:",
                "```\nfunction start() public override {\n    AddressInput.get(tvm.functionId(setAddress), \"Enter wallet address:\");\n}\nfunction setAddress(address value) public pure {\n    // TODO: continue here\n}\n```\n"
            ]
        },
        "AmountInput.get": {
            "prefix": "AmountInput.get",
            "body": "AmountInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:uint8 decimal}, ${4:uint128 min}, ${5:uint128 max});",
            "description": [
                "prints prompt message to the user and returns amount of tokens entered by user.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n - decimal: uint8 - number of decimals used by amount token, e.g. 9 - means that browser should multiply token amount to 1000000000 to get its debot represenation.\n - min: uint128 - minimal amount that can be entered by user.\n - max: uint128 - maximum amount that can be entered by user.\n",
                "Returns:",
                " - { value: uint128 } - amount of tokens multiplied by `10^decimals`. To get the integer part of an amount debot should divide value by `10^decimals`.",
                "\nExample:",
                "```\nfunction start() public override {\n    AmountInput.get(tvm.functionId(setAmount), \"Enter amount of evers:\",  9, 1e9, 100e9);\n}\nfunction setAmount(uint128 value) public pure {\n    // TODO: continue here\n}\n```"
            ]
        },
        "Base64.encode": {
            "prefix": "Base64.encode",
            "body": "Base64.encode(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\");",
            "description": [
                "Encode Base64 string",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback",
                " - data: bytes — input binary data",
                "Returns:",
                " - base64: string — base64 string",
                "\nExample:",
                "```\nfunction start() public override {\n    Base64.encode(tvm.functionId(setEncoded), \"abc\");\n}\nfunction setEncoded(string base64) public {\n    require(base64==\"YWJj\",101);\n    Base64.decode(tvm.functionId(setDecoded), base64);\n}\nfunction setDecoded(bytes data) public {\n    require(data==\"abc\",102);\n    // TODO: continue here\n}\n```"
            ]
        },
        "Base64.decode": {
            "prefix": "Base64.decode",
            "body": "Base64.decode(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:string base64}\");",
            "description": [
                "Decode Base64 string",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback",
                " - base64: string — base64 string",
                "Returns:",
                " - data: bytes — output binary data",
                "\nExample:",
                "```\nfunction start() public override {\n    Base64.encode(tvm.functionId(setEncoded), \"abc\");\n}\nfunction setEncoded(string base64) public {\n    require(base64==\"YWJj\",101);\n    Base64.decode(tvm.functionId(setDecoded), base64);\n}\nfunction setDecoded(bytes data) public {\n    require(data==\"abc\",102);\n    // TODO: continue here\n}\n```"
            ]
        },
        "ConfirmInput.get": {
            "prefix": "ConfirmInput.get",
            "body": "ConfirmInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\");",
            "description": [
                "Prints prompt message to the user and returns true or false choice",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n\nReturns:\n\n{ value: bool }\n",
                "Example:\n```\nfunction start() public override {\n    ConfirmInput.get(tvm.functionId(setConfirm), \"Say yes or no:\");\n}\nfunction setConfirm(bool value) public pure {\n    // TODO: continue here\n}\n```"
            ]
        },
        "CountryInput.get": {
            "prefix": "CountryInput.get",
            "body": "CountryInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:string[] permitted}, ${4:string[] banned});",
            "description": [
                "Allows to get the country code entered by the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user before input\n - permitted: string[] - if not empty, list of country codes permitted for input\n - banned: string[] - if not empty, list of country codes banned for input\n\nReturns:\n\n - value: string — country code (ISO 3166-1 alpha-2) entered by user\n",
                "Example:\n```\nfunction start() public override {\n    CountryInput.get(tvm.functionId(setCountryCode), \"Enter your country code:\", [], []);\n    // or if Russia, Bulgaria and Cuba permitted for input:\n    // CountryInput.get(tvm.functionId(setCountryCode), \"Enter your country code:\", ['RU', 'BG', 'CU'], []);\n    // or if the drop-down list of countries should not include North Korea and Lebanon\n    // CountryInput.get(tvm.functionId(setCountryCode), \"Enter your country:\", [], ['KP', 'LB']);\n}\nfunction setCountryCode(string value) public pure {\n    // TODO: continue here\n}\n```"
            ]
        },
        "DateTimeInput.getDate": {
            "prefix": "DateTimeInput.getDate",
            "body": "DateTimeInput.getDate(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:int128 defaultDate}, ${4:int128 minDate}, ${5:int128 maxDate});",
            "description": [
                "returns date timestamp selected by user.\nNote: function accepts date in unixtime (seconds from the midnight UTC-0 of 1st Jan 1970) which is int128 bits long, negative values are allowed. Date unixtime includes day, month, year and 0 hours, 0 minutes and 0 seconds.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user before input.\n - defaultDate: int128 - date by default.\n - minDate: int128 - minimum date that can be chosen.\n - maxDate: int128 - maximum date that can be chosen.\n\nReturns:\n\n date: int128 - chosen date unixtime (UTC-0).",
                "\nExample:```\nfunction start() public override {\n    DateTimeInput.getDate(tvm.functionId(setDate),\n        \"Choose a day in 2021 from the begining until current day:\", \n        int128(now), 1609448400, int128(now));\n}\nfunction setDate(int128 date) public {\n    // TODO: continue here\n}\n```"
            ]
        },
        "DateTimeInput.getTime": {
            "prefix": "DateTimeInput.getTime",
            "body": "DateTimeInput.getTime(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:uint32 defaultTime}, ${4:uint32 minTime}, ${5:uint32 maxTime}, ${6:uint8 Interval});",
            "description": [
                "returns the timestamp within a day selected by the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user before input.\n - defaultTime: uint32 — time by default.\n - minTime: uint32 — minimum time that can be chosen.\n - maxTime: uint32 — maximum time that can be chosen.\n - minuteInterval: uint8 - minimal allowed minuteInterval between neibour times in minutes. Valid values are {1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30}.\n\nReturns:\n\n time: uint32 — chosen timestamp.",
                "\nExample:```\nDateTimeInput.getTime(tvm.functionId(setTime), \n\"Choose a day time (local):\", \n55800, 55800, 86100, 1);\n```"
            ]
        },
        "DateTimeInput.getDateTime": {
            "prefix": "DateTimeInput.getDateTime",
            "body": "DateTimeInput.getDateTime(tvm.functionId(${1:uint32 callbackFunctionId}), \"${2:bytes prompt}\", ${3:int128 defaultDatetime}, ${4:int128 minDatetime}, ${5:int128 maxDatetime}, ${6:uint8 minuteInterval}, ${7:uint8 minuteInterval}, ${8:int16 inTimeZoneOffset});",
            "description": [
                "allow to select date and time.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n - defaultDatetime:  int128 - unixtime, default date and time.\n - minDatetime: int128 - unixtime, minimum allowed date and time to choose.\n - maxDatetime: int128 - unixtime, maximum allowed date and time to choose.\n - minuteInterval: uint8 - minimal allowed minuteInterval between neibour times in minutes. Valid values are {1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30}.\n - inTimeZoneOffset: int16 - time zone offset related to UTC-0 in minutes. There is a special value 0x7FFF which defines local user time zone.\n\nReturns:\n\n datetime: int128 - unixtime of chozen date and time.\n - timeZoneOffset: int16 - time zone offset in minutes. Use this value for correct date and time representation for the user.\n "
            ]
        },
        "DateTimeInput.getTimeZoneOffset": {
            "prefix": "DateTimeInput.getTimeZoneOffset",
            "body": "DateTimeInput.getTimeZoneOffset(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "returns user time zone offset in minutes.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n timeZoneOffset: int16 - user time zone offset in minutes."
            ]
        },
        "EncryptionBoxInput.getNaclSecretBox": {
            "prefix": "EncryptionBoxInput.getNaclSecretBox",
            "body": "EncryptionBoxInput.getNaclSecretBox(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes nonce});",
            "description": [
                "Prints prompt message to the user and returns handle to opened Nacl secret box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input, OPTIONAL (empty string is similar to null).\n - nonce: bytes — bytes of nonce.\n\nReturns:\n\n - handle: uint32 — id of registered encryption box.\n"
            ]
        },
        "EncryptionBoxInput.getNaclBox": {
            "prefix": "EncryptionBoxInput.getNaclBox",
            "body": "EncryptionBoxInput.getNaclBox(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes nonce}, ${4:uint256 theirPubkey});",
            "description": [
                "Prints prompt message to the user and returns handle to Nacl box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input, OPTIONAL (empty string is similar to null).\n - nonce: bytes — bytes of nonce.\n - theirPubkey: uinit256 - receiver's public key.\n\nReturns:\n\n - handle: uint32 — id of registered encryption box.\n "
            ]
        },
        "EncryptionBoxInput.getChaCha20Box": {
            "prefix": "EncryptionBoxInput.getChaCha20Box",
            "body": "EncryptionBoxInput.getChaCha20Box(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes nonce});",
            "description": [
                "Prints prompt message to the user and returns handle to ChaCha20 box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input, OPTIONAL (empty string is similar to null).\n - nonce: bytes — 96-bit nonce.\n\nReturns:\n\n - handle: uint32 — id of registered encryption box.\n"
            ]
        },
        "EncryptionBoxInput.remove": {
            "prefix": "EncryptionBoxInput.remove",
            "body": "EncryptionBoxInput.remove(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint256 handle});",
            "description": [
                "Removes encryption box handle from Browser and destroys underlying Encryption Box.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - handle: uint32 — encryption box handle to remove. This handle becomes invalid after removing.\n\nReturns:\n\n - removed: bool - true if handle was found and successfully removed. Otherwise false.\n "
            ]
        },
        "EncryptionBoxInput.getSupportedAlgorithms": {
            "prefix": "EncryptionBoxInput.getSupportedAlgorithms",
            "body": "EncryptionBoxInput.getSupportedAlgorithms();",
            "description": [
                "Returns a list of algorithms supported by DeBot Browser.",
                "Returns: names: bytes[] — array of algorithm names supported by DeBot Browser."
            ]
        },
        "Hex.encode": {
            "prefix": "Hex.encode",
            "body": "Hex.encode(tvm.functionId(${1:uint32 callbackFunctionId}),${2:bytes data});",
            "description": [
                "Encode data to hex format.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - data: bytes — input binary data.\n\nReturns:\n\n - hexstr: string — hex string\n",
                "Example:\n```\nbytes data = bytes(\"aaa\");\nHex.encode(tvm.functionId(setEncode), data);\n```"
            ]
        },
        "Hex.decode": {
            "prefix": "Hex.decode",
            "body": "Hex.decode(tvm.functionId(${1:uint32 callbackFunctionId}),${2:string hexstr});",
            "description": [
                "Decode string from base64 format.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - hexstr: string — hex string.\n\nReturns:\n\n - data: bytes — output binary data\n",
                "Example:\n```\nstring hexstr = \"616161\";\n Hex.decode(tvm.functionId(setDecode), hexstr);\n```"
            ]
        },
        "Json.deserialize": {
            "prefix": "Json.deserialize",
            "body": "Json.deserialize(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:string json});",
            "description": [
                "Deserialize json into the structure.",
                "\nArguments:",
                "answerId: uint32 — function id of result callback. Callback function should have two input parameters: \"result\" of type bool and \"obj\" of type <StructName>.\n - json: string — json utf8 string.\n\nReturns:\n\n - result: bool - result of operation:\n    true - operation succeeded;\n    false - operation failed.\n - obj: <StructName> - deserialised json into structure of type <StructName>\nNote: type of obj parameter is set by StructName input parameter. And input parameters of answerId function should have two input parameters: \"result\" of type bool and \"obj\" of type StructName.\n "
            ]
        },
        "Media.output": {
            "prefix": "Media.output",
            "body": "Media.output(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes data});",
            "description": [
                "Allows to show media of different formats (images, docs and others) to the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — utf-8 string to print to the user on top of media.\n - data: bytes — utf-8 string with encoded media according to [RFC2397](https://datatracker.ietf.org/doc/html/rfc2397).\n\nReturns:\n\nMediaStatus - status of media output.",
                "Example:\n```\nMedia.output(tvm.functionId(setResult), \"PNG image\", format(\"data:image/png;base64,{}\", m_pngBase64));\n//=>function setResult(MediaStatus result);\n```"
            ]
        },
        "Media.getSupportedMediaTypes": {
            "prefix": "Media.getSupportedMediaTypes",
            "body": "Media.getSupportedMediaTypes(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Returns array of supported media types.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\nmediaTypes: bytes[] — array of strings with supported media types. Each string is in the format of \"type/subtype\". E.g. [\"image/png\", \"image/jpg\"]."
            ]
        },
        "Menu.select": {
            "prefix": "Menu.select",
            "body": "Menu.select(${1:bytes title}, ${2:bytes description}, [\n\tMenuItem(${3:bytes title}, ${4:string description}, tvm.functionId(${5:handleMenu1}))\n]);",
            "description": [
                "Prints prompt message to the user and returns string entered by user.",
                "\nArguments:",
                " - title: bytes — utf8 string with menu title.\n - description: bytes — utf8 string with a description of a menu. Optional, can be `\"\"` (empty string).\n - items: MenuItem[] - array of menu items.\n",
                "Returns:",
                " - index: uint32 — index of selected menu item starting from 0.\n",
                "MenuItem\n",
                " - title: bytes — utf8 string with a short name of menu item. \n - description: string — utf8 string describing details of menu item. Optional, can be \"\" (empty string). \n - handlerId: uint32 — id of a callback function to be called when this item is selected.\n",
                "Example:\n```\nfunction _menu() private inline {\n    Menu.select(\"Main menu\", \"description for menu\", [\n        MenuItem(\"menu 1\", \"\", tvm.functionId(handleMenu1)),\n        MenuItem(\"menu 2\", \"desc for menu 2\", tvm.functionId(handleMenu2))\n    ]);\n}\n```\n"
            ]
        },
        "MenuItem": {
            "prefix": "MenuItem",
            "body": "MenuItem(${1:bytes title}, ${2:string description}, tvm.functionId(${3:handleMenu1}));",
            "description": [
                "MenuItem \n - title: bytes — utf8 string with a short name of menu item.  \n - description: string — utf8 string describing details of menu item. Optional, can be \"\" (empty string).  \n - handlerId: uint32 — id of a callback function to be called when this item is selected.  \n\t"
            ]
        },
        "Network.get": {
            "prefix": "Network.get",
            "body": "Network.get(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:string url}, ${3:string[] headers});",
            "description": [
                "Load data from the server using an HTTP GET request.",
                "\nArguments:",
                " - answerId: uint32 — id of callback function.\n - url: string — utf8 string with the name of the resource that you wish to fetch.\n - headers: string[] — array of utf8 strings with HTTP headers that you want to add to your request.\n\nReturns:\n\n - statusCode: int32 - response status code.\n - retHeaders: string[] - array of utf8 strings with response headers.\n - content: string — response body as utf8 string.\n"
            ]
        },
        "Network.post": {
            "prefix": "Network.post",
            "body": "Network.post(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:string url}, ${3:string[] headers}, ${4:string body});",
            "description": [
                "Send data to the server using an HTTP POST request.",
                "\nArguments:",
                " - answerId: uint32 — id of callback function.\n - url: string — utf8 string with the name of the resource that you wish to fetch.\n - headers: string[] — array of utf8 strings with HTTP headers that you want to add to your request.\n - body: string — utf8 string with HTTP request body.\n\nReturns:\n\n- statusCode: int32 - response status code.\n- retHeaders: string[] - array of utf8 strings with response headers.\n- content: string — response body as utf8 string.\n"
            ]
        },
        "NumberInput.get": {
            "prefix": "NumberInput.get",
            "body": "NumberInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:int256 min}, ${4:int256 max});",
            "description": [
                "Interface for number input.",
                "\nArguments:",
                " - answerId: uint32 — id of callback function.\n - prompt: bytes — utf-8 string to print to the user before input.\n - min: int256 - minimal value allowed to input.\n - max: int256 - maximum value allowed to input.\n\nReturns:\n\n- { value: int256 }",
                "\nExample:\n```\nfunction start() public override {\n    NumberInput.get(tvm.functionId(setNumber), \"Enter number:\", -10, 100);\n}n - $1function setNumber(int256 value) public pure {\n    // TODO: continue here\n}\n```\n"
            ]
        },
        "QRCode.read": {
            "prefix": "QRCode.read",
            "body": "QRCode.read(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt});",
            "description": [
                "Scans qrcode by camera or from image and returns its decoded data as string.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - prompt: bytes — utf-8 string with message to the user. Optional, empty string \"\" is treated like null.\n\nReturns:\n\nvalue: bytes — utf8 string with qrcode data.\nresult: uint8 — one of the `QRStatus` value. `Success` on success.",
                "\nExample:\n```\nfunction start() public override {\n    NumberInput.get(tvm.functionId(setNumber), \"Enter number:\", -10, 100);\n}n - $1function setNumber(int256 value) public pure {\n    // TODO: continue here\n}\n```\n"
            ]
        },
        "QRCode.draw": {
            "prefix": "QRCode.draw",
            "body": "QRCode.draw(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bytes text});",
            "description": [
                "Prints text as QR Code to the user.\nNote: DeBot Browsers can manually choose data correction level.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - prompt: bytes — utf-8 string with message to the user. Optional, empty string \"\" is treated like null.\n - text: bytes — utf-8 string to print as QRCode.\n\nReturns:\n\nresult: uint8 — one of the `QRStatus` value. `Success` on success and `ScannerError` on error.\nenum QRStatus { Success = 0, DataTooLong = 1, InvalidCharacter = 2, ScannerError = 3, Canceled = 4, NotSupported = 5 }",
                "\nExample:\n```\nQRCode.draw(tvm.functionId(setDrawResult), \"DeBot address\", format(\"{}\", address(this)));\n//=>function setDrawResult(QRStatus result)\n```"
            ]
        },
        "Query.collection": {
            "prefix": "Query.collection",
            "body": "Query.collection(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint8 collectionType}, ${3:bytes queryFilter}, ${4:bytes returnFilter}, ${5:uint32 limit}, ${6:orderBy QueryOrderBy});",
            "description": [
                "Makes a query to blockchain with a certain filter.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - collectionType: uint8 — one of the \"CollectionType\" variants: \n    Accounts (0), Messages (1), Transactions(2). \n - queryFilter: bytes — utf-8 string with object query.\n - returnFilter: bytes — utf-8 string with object query.\n - limit: uint32 — maximum number of objects that can be returned in result array.\n - orderBy: QueryOrderBy — structure that defines sorting rules for returning objects.\n \n Returns:\n - status: uint8 — one of the \"QueryStatus\" variants.\n - objects: JsonLib.Value[] — array of json values. Every json value represents fields requested in \"returnFilter\" for certain \"CollectionType\" variant: message, transaction, account.\n"
            ]
        },
        "Query.waitForCollection": {
            "prefix": "Query.waitForCollection",
            "body": "Query.waitForCollection(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint8 collectionType}, ${3:string queryFilter}, ${4:string returnFilter}, ${5:uint32 timeout});",
            "description": [
                "Returns an object that fulfills the conditions or waits for its appearance.",
                "\nArguments:",
                "\n - answerId: uint32 - id of function callback.\n - collectionType: uint8 - one of the `CollectionType` variants: \n    Accounts (0), Messages (1), Transactions(2). \n    See Query.sol for details.\n - queryFilter: string - utf-8 string with collection filter.\n - returnFilter: string - utf-8 string with projection (result) string.\n - timeout: uint32 - query timeout in ms.\n\n returns:\n \n- status: uint8 - one of the `QueryStatus` variants. See `Query.sol` for details.\n- object: JsonLib.Value - json value with fields requested in `returnFilter` for certain `CollectionType` variant: message, transaction, account.\n"
            ]
        },
        "Query.query": {
            "prefix": "Query.query",
            "body": "Query.query(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:string query}, ${3:string variables});",
            "description": [
                "Performs DAppServer GraphQL query and returns result provided by DAppServer.",
                "\nArguments:",
                "\n - answerId: uint32 - id of function callback.\n - query: string - GraphQL query text.\n - variables: string - Variables used in query.\n\nReturns:\n\n - status: uint8 - one of the `QueryStatus` variants. See `Query.sol` for details.\n - object: JsonLib.Value - json value provided by DAppServer.\n"
            ]
        },
        "Sdk.getBalance": {
            "prefix": "Sdk.getBalance",
            "body": "Sdk.getBalance(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:address addr});",
            "description": [
                "Get account balance",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - addr    : address — address of contract.\n\nReturns:\n\n- nanotokens: uint128 - account balance in nanotokens.\n"
            ]
        },
        "Sdk.getAccountType": {
            "prefix": "Sdk.getAccountType",
            "body": "Sdk.getAccountType(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:address addr});",
            "description": [
                "Get account type",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - addr    : address — address of contract.\n\nReturns:\n\n - acc_type: int8 - account type. Valid values are -1 (unexist), 0 (uninit), 1 (active), 2 (frozen).\n"
            ]
        },
        "Sdk.getAccountCodeHash": {
            "prefix": "Sdk.getAccountCodeHash",
            "body": "Sdk.getAccountCodeHash(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:address addr});",
            "description": [
                "Get account code hash.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - addr    : address — smart contract address.\n\nReturns:\n\n - code_hash: uint256 - account code hash.\n"
            ]
        },
        "Sdk.encrypt": {
            "prefix": "Sdk.encrypt",
            "body": "Sdk.encrypt(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 boxHandle});",
            "description": [
                "Encrypt data with defined encryption box.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - boxHandle: uint32 — encryption box handle. Remark: it can be received through 'EncryptionBoxInput' interface.\n\nReturns:\n\n - result: uint32 — result code of operation. 0 if succeeded, otherwise SDK error code.\n - encrypted: bytes — encrypted data bytes.\n"
            ]
        },
        "Sdk.decrypt": {
            "prefix": "Sdk.decrypt",
            "body": "Sdk.decrypt(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 boxHandle});",
            "description": [
                "Decrypt data with defined encryption box.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - boxHandle: uint32 — encryption box handle. Remark: it can be received through 'EncryptionBoxInput' interface.\n\nReturns:\n\n - result: uint32 — result code of operation. 0 if succeeded, otherwise SDK error code.\n - decrypted: bytes — decrypted data bytes.\n"
            ]
        },
        "Sdk.signHash": {
            "prefix": "Sdk.signHash",
            "body": "Sdk.signHash(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 boxHandle}, ${3:uint256 hash});",
            "description": [
                "Sign data hash (256bits) with defined signing box.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - boxHandle: uint32 — signing box handle.\n - hash: uint256 — data hash to sign.\n\nReturns:\n\n- signature: bytes — 512 bits of signature.\n"
            ]
        },
        "Sdk.genRandom": {
            "prefix": "Sdk.genRandom",
            "body": "Sdk.genRandom(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint32 length});",
            "description": [
                "Generate random byte array of the specified length.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - length: uint32 — size of random byte array.\n\nReturns:\n\n - buffer: bytes — random bytes.\n"
            ]
        },
        "Sdk.substring": {
            "prefix": "Sdk.substring",
            "body": "Sdk.substring(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes str}, ${3:uint32 start}, ${4:uint32 count});",
            "description": [
                "Return string of count bytes starting from start byte of original string.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n - str: bytes — original string.\n - start: uint32 — index of byte in original string from which to start substring. 'start' must be less then length of original string.\n - count: uint32 — length in bytes of substring. Must be less or equal then ( 'str.legnth' - 'start' ).\n\nReturns:\n\nsubstr: bytes — substring of original string.\n "
            ]
        },
        "SecurityCardManagement.getBlockHashes": {
            "prefix": "SecurityCardManagement.getBlockHashes",
            "body": "SecurityCardManagement.getBlockHashes(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get H2, H3 hashes and serial number from security card. The browser should call getHashes function from the security card library to get H2, H3 and serial number. This will not work if the card applet has the status: \"TonWalletApplet is personalized.\"\n",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n\nReturns:\n\n- h2: uint256 - H2 hash\n- h3: uint256 - H3 hash\n- sn: uint192 — card serial number\n"
            ]
        },
        "SecurityCardManagement.turnOnWallet": {
            "prefix": "SecurityCardManagement.turnOnWallet",
            "body": "SecurityCardManagement.turnOnWallet(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint192 sn}, ${3:bytes p1}, ${4:bytes iv}, ${5:bytes cs});",
            "description": [
                "Verify and setup security card initial data. Before forwarding the request to a security card, a browser must request a pin code and send it to the card with other data.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - sn      : uint192 — card serial number\n - p1      : bytes — authentication password (128 bytes)\n - iv      : bytes — vector for AES128 CBC initialization for encrypting P1 (16 bytes)\n - cs      : bytes — common secret(32 bytes)\n\nReturns:\n\n- pubkey: uint256 - security card public key\n"
            ]
        },
        "SecurityCardManagement.setRecoveryData": {
            "prefix": "SecurityCardManagement.setRecoveryData",
            "body": "SecurityCardManagement.setRecoveryData(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes recoveryData});",
            "description": [
                "Set recovery data to security card",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - recoveryData : bytes — recovery data\n\nReturns:\n\n- result: bool - result of operation\n"
            ]
        },
        "SecurityCardManagement.getRecoveryData": {
            "prefix": "SecurityCardManagement.getRecoveryData",
            "body": "SecurityCardManagement.getRecoveryData(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get recovery data from security card",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n - recoveryData : bytes — recovery data.\n"
            ]
        },
        "SecurityCardManagement.getSerialNumber": {
            "prefix": "SecurityCardManagement.getSerialNumber",
            "body": "SecurityCardManagement.getSerialNumber(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get serial number of touched card",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n - serialNumber : uint192 — card serial number.\n"
            ]
        },
        "SecurityCardManagement.getCardList": {
            "prefix": "SecurityCardManagement.getCardList",
            "body": "SecurityCardManagement.getCardList(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get the list of serial numbers of the user's cards for which we have keys in Android keystore/iOS keychain. The browser should call getAllSerialNumbers function from the security card library to get the list of serial numbers of the cards.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\nlist : uint192[] - array of serial numbers of the cards\n"
            ]
        },
        "SecurityCardManagement.deleteCard": {
            "prefix": "SecurityCardManagement.deleteCard",
            "body": "SecurityCardManagement.deleteCard(tvm.functionId(${1:uint32 callbackFunctionId}, ${2:uint192 sn}));",
            "description": [
                "Delete key for given serialNumber from Android keystore/iOS keychain. The browser should call deleteKeyForHmac function from the security card library to get operation execution status (and finishDeleteKeyFromKeyChainAfterInterruption function if it is necessary).\n",
                "Arguments:\n\nanswerId: uint32 - function id of result callback\nsn:       uint192 - serial number of the card for checking\nreturns:\n\nresult: bool - result of operation\n"
            ]
        },
        "SecurityCardManagement.getTonWalletAppletState": {
            "prefix": "SecurityCardManagement.getTonWalletAppletState",
            "body": "SecurityCardManagement.getTonWalletAppletState(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Get card applet state.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback.\n\nReturns:\n\n - state : string — result of operation.\n"
            ]
        },
        "SecurityCardManagement.getPublicKey": {
            "prefix": "SecurityCardManagement.getPublicKey",
            "body": "SecurityCardManagement.getPublicKey(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes p1}, ${3:bytes cs}, ${4:uint192 sn});",
            "description": [
                "Allows to get the public key of the card\n",
                "Arguments:\n\nanswerId: uint32 - function id of result callback\nreturns:\n\npubkey: uint256 - public key of the card\n"
            ]
        },
        "SecurityCardManagement.isCardExists": {
            "prefix": "SecurityCardManagement.isCardExists",
            "body": "SecurityCardManagement.isCardExists(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:uint192 sn});",
            "description": [
                "Checks whether the key for this serial number exists in the Android keystore/iOS keychain. The browser should call\n",
                "Arguments:\n\nanswerId: uint32 - function id of result callback\nsn:       uint192 - serial number of the card for checking\nreturns:\n\nresult: bool - result of operation\n"
            ]
        },
        "SecurityCardManagement.createKeyForHmac": {
            "prefix": "SecurityCardManagement.createKeyForHmac",
            "body": "SecurityCardManagement.createKeyForHmac(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes p1}, ${3:bytes cs}, ${4:uint192 sn});\n",
            "description": [
                "Create secret key for HMAC SHA256. This key is saved into Android keystore or iOS keychain and then is used by the app to sign APDU commands data fields.",
                "\nArguments:",
                " - answerId: uint32  - function id of result callback\n - p1:       bytes   - authentication password (128 bytes) \n - cs:       bytes   - common secret(32 bytes)\n - sn:       uint192 — card serial number\nReturns: void.\n"
            ]
        },
        "SigningBoxInput.get": {
            "prefix": "SigningBoxInput.get",
            "body": "SigningBoxInput.get(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:uint256 possiblePublicKeys});",
            "description": [
                "Prints prompt message to the user and returns handle for selected SigningBox.",
                "\nArguments:",
                " - answerId: uint32 — id of function callback.\n - prompt: bytes — utf-8 string to print to the user before input.\n - possiblePublicKeys: uint256[] - keys for identification of signing box. Can be empty.\n\nReturns:\n\n{ handle: uint32 }\n",
                "Example:",
                "```\nfunction start() public override {\n    SigningBoxInput.get(tvm.functionId(setSigningBoxHandle), \"Enter my signing keys:\", [tvm.pubkey()]);\n}\nfunction setSigningBoxHandle(uint32 handle) public {\n    Terminal.print(0, format(\"Signing Box Handle: {}\", handle));\n}\n```\n"
            ]
        },
        "Terminal.input": {
            "prefix": "Terminal.input",
            "body": "Terminal.input(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes prompt}, ${3:bool multiline});",
            "description": [
                "Prints prompt message to the user and returns string entered by user.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n - prompt: bytes — string printed to the user and describing what to enter\n - multiline: bool - allow multiline text input\n\nReturns:\n\n - value: bytes — utf8 string entered by user.\n"
            ]
        },
        "Terminal.print": {
            "prefix": "Terminal.print",
            "body": "Terminal.print(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes message});",
            "description": [
                "Shows string message to the user",
                "\nArguments:",
                " - answerId: uint32 — function id of callback, can be 0.\n - message: bytes — utf8 string as byte array\nReturns: void\n",
                "Example:",
                "```\nTerminal.print(0, format(\"Hello {}\", \"World\"));\n```"
            ]
        },
        "Terminal.printf": {
            "prefix": "Terminal.printf",
            "body": "Terminal.printf(tvm.functionId(${1:uint32 callbackFunctionId}), ${2:bytes fmt}, ${3:cell fargs});",
            "description": [
                "Shows formatted string message to the user.",
                "\nArguments:",
                " - answerId: uint32 — function id of callback, can be 0.\n - fmt: bytes — utf8 string as byte array that must be printed to the user\n - fargs: cell - cell with serialized format arguments that must be inserted into 'format' string replacing format specifiers (subsequences between '{}' brackets).\nFormat specifier is one of ABI type like '{int32}', '{address}', '{cell}', '{uint256[]}' and so on or one of the following types:\n - '{utime}' - prints unixtime in UTC date time format. Format argument is an 'uint32' integer.\n    - '{ton}' - prints number of evers in 'decimal.float' format with 9 digits after '.'.\nReturns: void\n",
                "Example:",
                "```\nfunction formatPrint() public {\n    TvmBuilder b;\n    b.store(int8(1), uint32(10));\n    Terminal.printf(0, \"Enter number beetween {int8} and {uint32}\", b.toCell());\n}\n```\n"
            ]
        },
        "UserInfo.getAccount": {
            "prefix": "UserInfo.getAccount",
            "body": "UserInfo.getAccount(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Allows DeBots to receive TON address of user main account. Method should be implemented without user interaction if possible. Otherwise DeBot Browser should ask user to enter TON address of smart contract which can be considered the main user account. If user has no default account then zero address should be used.",
                "\nArguments:",
                " - answerId: uint32 — function id of result callback\n\nReturns:\n\n- value: address — TON address of main user account.\n"
            ]
        },
        "UserInfo.getPublicKey": {
            "prefix": "UserInfo.getPublicKey",
            "body": "UserInfo.getPublicKey(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Allows DeBots to receive user default public key. Method should be implemented without user interaction if possible. If user has no default public key then the method should return 0.",
                "\nArguments:",
                " - answerId: uint32 — function id of callback.\n\nReturns:\n\n - value: uint256 - user default public key, can be 0.\n"
            ]
        },
        "UserInfo.getSigningBox": {
            "prefix": "UserInfo.getSigningBox",
            "body": "UserInfo.getSigningBox(tvm.functionId(${1:uint32 callbackFunctionId}));",
            "description": [
                "Allows DeBot to receive handle to keypair which can be used to sign external messages to the address returned by UserInfo.getAccount. This function can return zero handle. In that case DeBot should not use it to sign messages and should implement other ways to recevie signing keypair (e.g using SigningBoxHandle interface or delegate DEngine to receive signing box from browser).",
                "\nArguments:",
                " - answerId: uint32 — function id of callback.\n\nReturns:\n\n - handle: uint32 — handle to signing keypair, can be 0.\n"
            ]
        },
        "this": {
            "prefix": "this",
            "body": "this",
            "description": "This is the refer to enum, struct or contract"
        },
        "extMsg": {
            "prefix": ".extMsg",
            "body": "extMsg",
            "description": "Call options similar to buildExtMsg function call. Note: this type of call should be used only offchain in debot contracts.\n"
        },
        "int": {
            "prefix": "int",
            "body": "int",
            "description": ""
        },
        "int8": {
            "prefix": "int8",
            "body": "int8",
            "description": "Range: [-128 : 127]"
        },
        "int16": {
            "prefix": "int16",
            "body": "int16",
            "description": "Range: [-32768 : 32767]"
        },
        "int32": {
            "prefix": "int32",
            "body": "int32",
            "description": "Range: [-2147483648 : 2147483647]"
        },
        "int64": {
            "prefix": "int64",
            "body": "uint64",
            "description": "Range: [-9223372036854775808 : 9223372036854775807]"
        },
        "int128": {
            "prefix": "int128",
            "body": "int128",
            "description": ""
        },
        "int256": {
            "prefix": "int256",
            "body": "int256",
            "description": ""
        },
        "uint": {
            "prefix": "uint",
            "body": "uint",
            "description": ""
        },
        "uint8": {
            "prefix": "uint8",
            "body": "uint8",
            "description": "Range: [0 : 255]"
        },
        "uint16": {
            "prefix": "uint16",
            "body": "uint16",
            "description": "Range: [0 : 65535]"
        },
        "uint32": {
            "prefix": "uint32",
            "body": "uint32",
            "description": "Range: [0 : 4294967295]"
        },
        "uint64": {
            "prefix": "uint64",
            "body": "uint64",
            "description": "Range: [0 : 18446744073709551615]"
        },
        "uint128": {
            "prefix": "uint128",
            "body": "uint128",
            "description": "Range: [0 : 340282366920938463463374607431768211455]"
        },
        "uint256": {
            "prefix": "uint256",
            "body": "uint256",
            "description": ""
        },
        "varInt16": {
            "prefix": "varInt16",
            "body": "varInt16",
            "description": "Use this type if you want to store or send integers, and they usually have small size."
        },
        "varInt32": {
            "prefix": "varInt32",
            "body": "varInt32",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "varUint": {
            "prefix": "varUint",
            "body": "varUint",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "varUint16": {
            "prefix": "varUint16",
            "body": "varUint16",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "varUint32": {
            "prefix": "varUint32",
            "body": "varUint32",
            "description": "Use this type if you want to store or send uintegers, and they usually have small size."
        },
        "ExtraCurrencyCollection": {
            "prefix": "ExtraCurrencyCollection",
            "body": "ExtraCurrencyCollection",
            "description": ""
        },
        "array": {
            "prefix": "array",
            "body": "array",
            "description": ""
        },
        "vector": {
            "prefix": "vector",
            "body": "vector(${1:Type}",
            "description": "vector(Type) is a template container type capable of storing an arbitrary set of values of a single type, pretty much like dynamic-sized array. \nTwo major differences are that vector(Type):\n1) is much more efficient than a dynamic-sized array;\n2) has a lifespan of a smart-contract execution, so it can't be neither passed nor returned as an external function call parameter, nor stored in a state variable.\n\nNote: vector implementation based on TVM Tuple type, and it has a limited length of 255 * 255 = 65025 values.\n"
        },
        "string": {
            "prefix": "string",
            "body": "string",
            "description": ""
        },
        "bool": {
            "prefix": "bool",
            "body": "bool",
            "description": ""
        },
        "hash": {
            "prefix": "hash",
            "body": "hash",
            "description": ""
        },
        "bytes2": {
            "prefix": "bytes2",
            "body": "bytes2",
            "description": ""
        },
        "<variant>.isUint": {
            "prefix": ".isUint",
            "body": "isUint()",
            "description": [
                "```\n<variant>.isUint() returns (bool)\n```\n",
                "Checks whether \\<variant\\> holds uint type."
            ]
        },
        "<variant>.toUint": {
            "prefix": ".toUint",
            "body": "toUint()",
            "description": [
                "Converts \\<variant\\> to uint type if it's possible. Otherwise, throws an exception with code 77.\n"
            ]
        },
        "try-catch": {
            "prefix": "try",
            "body": "try {\n\n}catch(variant value, uint16 number) { \n\n}",
            "description": [
                "The try statement allows you to define a block of code to be tested for errors while it is executed. The catch statement allows you to define a block of code to be executed, if an error occurs in the try block. catch block gets two parameters of type variant and uint, which contain exception argument and code respectively. \n"                
            ]
        },        
        "using ... for":{
            "prefix": "using",
            "body": "using ${1:Type} for ${2:Type};",
            "description": [
                "The directive `using A for B;` can be used to attach library functions (from the library `A`) to any type (`B`) in the context of the contract. These functions will receive the object they were called for as their first parameter. The effect of `using A for *;` is that the functions from the library `A` are attached to all types.\n"                
            ]
        },
        "type(T).max":{
            "prefix": "type(T).max",
            "body": "type(${1:T}).max",
            "description": [
                "Returns the largest value representable by the type T. \n"                
            ]
        }, 
        "type(T).min":{
            "prefix": "type(T).min",
            "body": "type(${1:T}).min",
            "description": [
                "Returns the smallest value representable by the type T. \n"                
            ]
        }
    }
}